{"meta":{"title":"Camel's Blog","subtitle":"","description":"Just a simple blog","author":"Camel","url":"https://Camel-zy.github.io/Camel_Blog","root":"/Camel_Blog/"},"pages":[{"title":"about","date":"2022-01-12T03:06:44.000Z","updated":"2022-01-12T03:07:11.986Z","comments":false,"path":"about/index.html","permalink":"https://camel-zy.github.io/Camel_Blog/about/index.html","excerpt":"","text":""},{"title":"archives","date":"2022-01-13T13:04:58.000Z","updated":"2022-01-13T13:05:13.995Z","comments":false,"path":"archives/index.html","permalink":"https://camel-zy.github.io/Camel_Blog/archives/index.html","excerpt":"","text":""},{"title":"categories","date":"2022-01-13T13:05:05.000Z","updated":"2022-02-05T05:04:12.586Z","comments":false,"path":"categories/index.html","permalink":"https://camel-zy.github.io/Camel_Blog/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2022-01-13T13:01:19.000Z","updated":"2022-01-13T13:01:37.251Z","comments":false,"path":"tags/index.html","permalink":"https://camel-zy.github.io/Camel_Blog/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"hexo配置","slug":"hexo配置","date":"2022-07-16T11:12:28.000Z","updated":"2022-07-16T11:12:28.332Z","comments":true,"path":"2022/07/16/hexo配置/","link":"","permalink":"https://camel-zy.github.io/Camel_Blog/2022/07/16/hexo%E9%85%8D%E7%BD%AE/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Ubuntu源文件备份","slug":"Ubuntu源文件备份","date":"2022-07-16T08:15:42.000Z","updated":"2022-07-16T08:16:42.899Z","comments":true,"path":"2022/07/16/Ubuntu源文件备份/","link":"","permalink":"https://camel-zy.github.io/Camel_Blog/2022/07/16/Ubuntu%E6%BA%90%E6%96%87%E4%BB%B6%E5%A4%87%E4%BB%BD/","excerpt":"之前源文件被我改得乱七八糟，现在重新恢复为官方源文件，顺便做个备份。","text":"之前源文件被我改得乱七八糟，现在重新恢复为官方源文件，顺便做个备份。 官方源文件备份 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#deb cdrom:[Ubuntu 20.04 LTS _Focal Fossa_ - Release amd64 (20200423)]/ focal main restricted# See http://help.ubuntu.com/community/UpgradeNotes for how to upgrade to# newer versions of the distribution.deb http://cn.archive.ubuntu.com/ubuntu/ focal main restricted# deb-src http://cn.archive.ubuntu.com/ubuntu/ focal main restricted## Major bug fix updates produced after the final release of the## distribution.deb http://cn.archive.ubuntu.com/ubuntu/ focal-updates main restricted# deb-src http://cn.archive.ubuntu.com/ubuntu/ focal-updates main restricted## N.B. software from this repository is ENTIRELY UNSUPPORTED by the Ubuntu## team. Also, please note that software in universe WILL NOT receive any## review or updates from the Ubuntu security team.deb http://cn.archive.ubuntu.com/ubuntu/ focal universe# deb-src http://cn.archive.ubuntu.com/ubuntu/ focal universedeb http://cn.archive.ubuntu.com/ubuntu/ focal-updates universe# deb-src http://cn.archive.ubuntu.com/ubuntu/ focal-updates universe## N.B. software from this repository is ENTIRELY UNSUPPORTED by the Ubuntu ## team, and may not be under a free licence. Please satisfy yourself as to ## your rights to use the software. Also, please note that software in ## multiverse WILL NOT receive any review or updates from the Ubuntu## security team.deb http://cn.archive.ubuntu.com/ubuntu/ focal multiverse# deb-src http://cn.archive.ubuntu.com/ubuntu/ focal multiversedeb http://cn.archive.ubuntu.com/ubuntu/ focal-updates multiverse# deb-src http://cn.archive.ubuntu.com/ubuntu/ focal-updates multiverse## N.B. software from this repository may not have been tested as## extensively as that contained in the main release, although it includes## newer versions of some applications which may provide useful features.## Also, please note that software in backports WILL NOT receive any review## or updates from the Ubuntu security team.deb http://cn.archive.ubuntu.com/ubuntu/ focal-backports main restricted universe multiverse# deb-src http://cn.archive.ubuntu.com/ubuntu/ focal-backports main restricted universe multiverse## Uncomment the following two lines to add software from Canonical&#x27;s## &#x27;partner&#x27; repository.## This software is not part of Ubuntu, but is offered by Canonical and the## respective vendors as a service to Ubuntu users.# deb http://archive.canonical.com/ubuntu focal partner# deb-src http://archive.canonical.com/ubuntu focal partnerdeb http://security.ubuntu.com/ubuntu focal-security main restricted# deb-src http://security.ubuntu.com/ubuntu focal-security main restricteddeb http://security.ubuntu.com/ubuntu focal-security universe# deb-src http://security.ubuntu.com/ubuntu focal-security universedeb http://security.ubuntu.com/ubuntu focal-security multiverse# deb-src http://security.ubuntu.com/ubuntu focal-security multiverse# This system was installed using small removable media# (e.g. netinst, live or single CD). The matching &quot;deb cdrom&quot;# entries were disabled at the end of the installation process.# For information about how to configure apt package sources,# see the sources.list(5) manual. Ubuntu阿里云镜像 只需将文件中archive.ubuntu.com替换为mirrors.aliyun.com即可。 ps:使用code sources.list可在vscode中打开文件。 替换为ZJU镜像同理。","categories":[],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://camel-zy.github.io/Camel_Blog/tags/Ubuntu/"}]},{"title":"Ubuntu控制笔记本性能释放","slug":"Ubuntu控制笔记本性能释放","date":"2022-06-18T12:18:08.000Z","updated":"2022-06-18T13:19:03.437Z","comments":true,"path":"2022/06/18/Ubuntu控制笔记本性能释放/","link":"","permalink":"https://camel-zy.github.io/Camel_Blog/2022/06/18/Ubuntu%E6%8E%A7%E5%88%B6%E7%AC%94%E8%AE%B0%E6%9C%AC%E6%80%A7%E8%83%BD%E9%87%8A%E6%94%BE/","excerpt":"在使用Ubuntu时发现性能无法得到完全释放，风扇转速也十分有限。","text":"在使用Ubuntu时发现性能无法得到完全释放，风扇转速也十分有限。 型号：华硕 天选2 一、问题描述在Win10中，电脑可使用Fn+F5切换性能释放模式（静音、平衡、增强），因此有了在Ubuntu下调整模式的想法。 二、一些尝试参照网络某些博客使用lm-sensors后，发现找不到可调节的风扇，并没有达到预期效果。 三、解决方式这种方式应该仅限于华硕笔记本。 In Kernel 5.6 there is a fan mode for asus laptops, check if you have /sys/devices/platform/asus-nb-wmi/throttle_thermal_policy 2 - Silent, 0 - Balance, 1 - Turbo, similar to the modes in armoury crate on windows. 在/sys/devices/platform/asus-nb-wmi/throttle_thermal_policy内存储的数字即为当前模式： 其中默认的0代表平衡模式，1代表增强模式，2代表静音模式。 所以解决方法就很简单啦 修改该文件的值即可。 在这边也简单记录下命令。 1234su # 需要权限echo 1 &gt; /sys/devices/platform/asus-nb-wmi/throttle_thermal_policy # 切换为增强模式echo 0 &gt; /sys/devices/platform/asus-nb-wmi/throttle_thermal_policy # 切换为平衡模式echo 2 &gt; /sys/devices/platform/asus-nb-wmi/throttle_thermal_policy # 切换为静音模式 嫌命令麻烦的话也可以看看这个仓库，不过我没试过。 四、参考资料How to control fans on an asus laptop","categories":[],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"https://camel-zy.github.io/Camel_Blog/tags/ubuntu/"}]},{"title":"sqlmap使用笔记","slug":"sqlmap使用笔记","date":"2022-05-12T10:49:17.000Z","updated":"2022-05-12T12:06:01.873Z","comments":true,"path":"2022/05/12/sqlmap使用笔记/","link":"","permalink":"https://camel-zy.github.io/Camel_Blog/2022/05/12/sqlmap%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/","excerpt":"记录一下sqlmap的（非常基础的）知识啥的","text":"记录一下sqlmap的（非常基础的）知识啥的 sqlmap从入门到入狱 一、sqlmap简介 SQLMap 是一个开源的渗透测试工具，可以用来进行自动化检测，利用 SQL 注入漏洞，获取数据库服务器的权限。它具有功能强大的检测引擎，针对各种不同类型数据库的渗透测试的功能选项，包括获取数据库中存储的数据，访问操作系统文件甚至可以通过外带数据连接的方式执行操作系统命令。 sqlmap支持的五种不同的注入方式： Boolean-based blind：sqlmap 替换或附加到 HTTP 请求中的受影响参数，包含 SELECT 子语句的语法有效的 SQL 语句字符串，或用户要检索其输出的任何其他 SQL 语句。对于每个 HTTP 响应，通过在 HTTP 响应标头 / 正文与原始请求之间进行比较，该工具可以逐字符推断注入的语句的输出。或者，用户可以提供字符串或正则表达式以匹配 True 页面。在 sqlmap 中实现的用于执行此技术的二等分算法能够获取最多七个 HTTP 请求的输出每个字符。如果输出不在明文纯字符集内，则 sqlmap 将采用更大范围的算法来检测输出。 Time-based blind：sqlmap 替换或附加到 HTTP 请求中的受影响参数，该语法有效的 SQL 语句字符串包含查询，该查询将使后端 DBMS 保留一定的秒数。对于每个 HTTP 响应，通过在 HTTP 响应时间和原始请求之间进行比较，该工具可以逐字符推断注入的语句的输出。像基于布尔的技术一样，应用二等分算法。 Error-based：sqlmap 替换或附加到受影响的参数特定于数据库的错误消息引发语句，并解析 HTTP 响应标头和正文，以查找包含已注入的预定义字符链和其中的子查询语句输出的 DBMS 错误消息。仅当 Web 应用程序已配置为公开后端数据库管理系统错误消息时，此技术才有效。 UNION query-based：sqlmap 将一个语法有效的 SQL 语句附加到受影响的参数，该语句以开头 UNION ALL SELECT。当 Web 应用程序页面 SELECT 在 for 循环或类似情况下直接传递语句的输出时，此技术有效，以便查询输出的每一行都打印在页面内容上。sqlmap 还能够利用部分（单项）UNION 查询 SQL 注入漏洞，该漏洞在语句的输出未在 for 构造中循环而仅显示查询输出的第一项时发生。联合查询分为内联（inner join）、左联（left outer join）、右联（right outer join）和全联（full outer join） Stacked queries：sqlmap 测试 Web 应用程序是否支持堆叠查询，然后在支持的情况下将 HTTP 请求后的分号（;）附加到受影响的参数上，后跟 SQL 语句以被执行。此技术对于运行除 SELECT（例如）数据定义或数据操作语句以外的 SQL 语句很有用，这可能导致文件系统的读写访问和操作系统命令的执行，具体取决于底层的后端数据库管理系统和会话用户特权。 软件可直接通过官网下载安装 github项目地址 二、使用方式指定目标1$ python3 sqlmap.py -u &quot;url&quot; #指定目标网址 url的最后应当有参数 例如questionid=0 可能会问是否需要提高测试等级 比较推荐使用 3 等级进行测试。 也可以使用 –level 指定测试等级 列出库1$ python3 sqlmap.py -u &quot;url&quot; --dbs 列出表1$ python3 sqlmap.py -u &quot;url&quot; -D 库名 --tables 列出字段1$ python3 sqlmap.py -u &quot;url&quot; -D 库名 -T 表名 --columns 后面有空再写 咕咕咕 参考资料SQLMap 从入门到入狱详细指南 SqlMap中文版使用教程","categories":[],"tags":[{"name":"note","slug":"note","permalink":"https://camel-zy.github.io/Camel_Blog/tags/note/"},{"name":"sqlmap","slug":"sqlmap","permalink":"https://camel-zy.github.io/Camel_Blog/tags/sqlmap/"}]},{"title":"从零开始使用浙江大学自动健康打卡","slug":"从零开始使用浙江大学自动健康打卡","date":"2022-05-10T13:29:31.000Z","updated":"2022-05-11T14:44:29.160Z","comments":true,"path":"2022/05/10/从零开始使用浙江大学自动健康打卡/","link":"","permalink":"https://camel-zy.github.io/Camel_Blog/2022/05/10/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E8%87%AA%E5%8A%A8%E5%81%A5%E5%BA%B7%E6%89%93%E5%8D%A1/","excerpt":"由于目前一天不打卡就会被取消蓝码，所以大家对自动打卡的需求也就越来越高。","text":"由于目前一天不打卡就会被取消蓝码，所以大家对自动打卡的需求也就越来越高。 为节约每天重复的打卡时间，也尽可能避免忘记打卡造成的麻烦，自动打卡应运而生。 为了降低自动打卡的使用门槛，所以就有了这份胎教级教程，从零开始实现自动健康打卡。 顺带一提，目前github上的自动打卡在众多开发者的努力下功能已较为完善，稳定性也比最初提升了不少。 〇、特别声明本文禁止任何形式的转载。 本文仅用于学习交流使用，请严格遵守校纪校规，如实上报健康状态。对一切非法使用所产生的后果概不负责。 若本文侵犯到您的利益请联系我删除。 一、注册github 神说：要有github。 作为世界上最大的同性交友网站代码托管平台，github上超2亿代码库。我目前是用的自动打卡也是来自于此。 打开github，点击右上角的Sign Up 根据提示完成注册即可。（国内访问github可能不稳定，若无法访问可以过一段时间再试。如果有魔法的话访问速度会快一点 二、 Fork自动健康打卡仓库完成注册并登录后，打开自动健康打卡仓库，我目前使用的就是这个AutoCard仓库。 然后点击右上角的Fork，也就是将代码复制到自己的仓库。然后点击create fork 页面跳转后，若红框处左上角为你的用户名，且下面有一行fork from什么的小字，则说明fork已完成。 三、钉钉推送因为自动打卡可能会失败，需要你每天关注一下有没有打卡成功，所以需要开个钉钉推送功能。 首先随便新建个群，用于消息推送。 然后在电脑端（你前面不会一直是在手机上操作的吧）打开钉钉的那个群，点右上角群设置-&gt;智能群助手-&gt;添加机器人-&gt;设置 点击自定义-&gt;添加 机器人名字可随便写，但注意勾选加签，并点击下面的复制按钮复制生成的密钥，找个地方记录下，等会要用 点击完成后，点击复制按钮复制生成的Webhook，找个地方记录下，等会要用 四、仓库设置添加Secrets回到刚才你的仓库，点击Settings-&gt;Secrets&gt;Actions 点击New repository secret Name中填写AUTOCARD_USER Value中填写你的浙大通行证账号 然后点击Add secret 重复上述两步操作继续添加secret 其中Name和Value参照以下表格 那个AUTOCARD_CACHE_FLAG的Value填1即可 Name Value 备注 AUTOCARD_USER 浙大通行证账号 AUTOCARD_PWD 浙大通行证密码 AUTOCARD_DINGTALK_URL 第三步中记录的Webhook AUTOCARD_DINGTALK_SECRET 第三步中记录的密钥 AUTOCARD_CACHE_FLAG 1 用于程序缓存输出提供一个索引，任意值即可 AUTOCARD_MAX_TRIAL 5 打卡失败后重试次数 AUTOCARD_DELAY 0 是否随机延迟打卡 可选项：打卡时间修改回到code页面，点击红框中的workflow 点击schedule.yml 点击右侧的笔 修改此处的cron即可修改每日打卡的时间，例如我将这个改为了- cron: &#39;20 16,0 * * *&#39;，即协调世界时的每天16:20和00:20尝试打卡一次。（每天打两次是双保险，自动打卡有可能会失败） 具体cron语法可以自行查询 修改完后点击Start commit -&gt; Commit changes 即可 修改完后点击Start commit -&gt; Commit changes 即可 启动Actions点击上方Actions，并点击绿框启用Actions 点击左边的schedule 再点击右边的enable workflow 此时已完成设置。 测试一下下看到仓库右上角的小星星没 下面要跟着做呦 点一下这个小星星，它会变亮。 再点一下，它就灭了。 这真的不是单纯为了逗你玩 其实是为了让Action跑一遍 这边这个黄圈就意味着已经在运行啦 稍等一会，这个东西可能有点慢。 过一段时间看看钉钉刚才那个群里有没有收到消息推送。 okk如果一切顺利的话应该就已经完成设置啦，记得每天看一下有没有打卡成功就行啦。 五、部分问题处理如果不熟悉上述的这些东西的话，自动打卡出问题时可能处理起来也会比较困难。 那遇到问题怎么办呢？ 自己看着办咯 可以康康下面的常见问题。 代码库需要更新这个自动健康打卡的库有大佬在维护，时不时可能会需要更新。 辣么如何更新呢？ 进入你的仓库Code页面 点击Fetch upstream。如果显示如下图的话就需要更新。 点击Fetch and merge 大概还需要再点个绿框 这样就可以啦。 无需更新的话是如下图所示。 打卡失败 如何重新启动脚本？一般来讲提示信息获取失败或者压根没推送信息那就说明自动打卡失败了。 进入你的仓库Actions界面 点击红框中的schedule 再点击Re-run all jobs -&gt; Re-run jobs 即可重新运行一次。","categories":[],"tags":[{"name":"github","slug":"github","permalink":"https://camel-zy.github.io/Camel_Blog/tags/github/"},{"name":"script","slug":"script","permalink":"https://camel-zy.github.io/Camel_Blog/tags/script/"}]},{"title":"在双系统中共享蓝牙","slug":"在双系统中共享蓝牙鼠标","date":"2022-04-25T12:20:17.000Z","updated":"2022-04-25T13:36:12.128Z","comments":true,"path":"2022/04/25/在双系统中共享蓝牙鼠标/","link":"","permalink":"https://camel-zy.github.io/Camel_Blog/2022/04/25/%E5%9C%A8%E5%8F%8C%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%85%B1%E4%BA%AB%E8%93%9D%E7%89%99%E9%BC%A0%E6%A0%87/","excerpt":"双系统在切换系统后，蓝牙鼠标需要重新配对连接。 以下方法可解决这一问题","text":"双系统在切换系统后，蓝牙鼠标需要重新配对连接。 以下方法可解决这一问题 前言首先简单解释下蓝牙在双系统中需要重新配对的原因： 蓝牙配对是根据设备的MAC地址和随机生成的密钥连接，同一设备的MAC地址相同但在双系统中随机生成的密钥不同，因此每次切换系统连接都需重新配对。 本文所提的方法原理为更改Linux下的密钥使之与Windows下的密钥相同。 在Linux中配对蓝牙设备在Linux中配对蓝牙，从而在Linux中生成配置文件。 在Windows中配对蓝牙设备在Windows中配对蓝牙，从而在Windows中生成配置文件。 读取Windows下配置文件以下为方便起见采用在Linux下使用dumphive软件读取Windows下配置文件的方法 获取dumphive该软件目前已停止更新，源码可以在此此镜像站获取，或使用本站提供的备份文件 编译dumphive该软件使用Free Pascal编写（这都是些什么古董），故需要Free Pascal编译器。 1sudo apt install fpc 然后进入到源码的src目录下 1make 即可完成编译，得到dumphive文件。 读取注册表1234567891011sudo mount /dev/nvme0n1p3 /mnt # nvme0n1p3 是 Windows 系统盘cd /mnt/Windows/System32/config ~/dumphive SYSTEM ~/system.reg # 此处将dumphive至于~目录下grep -Pn &#x27;BTHPORT.*(\\\\[\\da-f]&#123;12&#125;)&#123;2&#125;&#x27; ~/system.reg #获取蓝牙配对相关信息171486:[ROOT\\ControlSet001\\Services\\BTHPORT\\Parameters\\Keys\\ec2exxxxxxxx\\ed5fxxxxxx95]# 返回值最前面的数字即为此信息所在的行号vim ~/system.reg +171486 # 打开文件，并将光标移动到171486行，即可看到蓝牙配对相关信息 修改蓝牙配对信息123456sudo sucd /var/lib/bluetooth/EC\\:2E\\:XX\\:XX\\:XX\\:XX/ # 进入此电脑的蓝牙目录（文件名为电脑MAC地址）cd ED\\:5F\\:XX\\:XX\\:XX\\:94/ # 进入配对设备的目录（文件名为配对设备MAC地址）# 注：此时发现文件名与上面注册表中不同（末位可能不同） 需要更改文件名# 更改后cd ED\\:5F\\:XX\\:XX\\:XX\\:95/ 接下来根据注册表中内容和以下对应表格修改参数 Windows Linux 参数格式修改 LTK [LongTermKey] Key 去逗号改大写 IRK [IdentityResolvingKey] Key 去逗号改大写 EDIV [LongTermKey] EDiv 十六进制转十进制 ERand [LongTermKey] Rand 倒序十六进制转十进制 特别注意：ERand需先倒序再转换进制 例如： 1&quot;ERand&quot;=hex(b):55,8c,80,38,10,7f,e1,b7 应先倒序相连变为b7e17f1038808c55 再转十进制变为13250011286344862805 重启蓝牙1sudo systemctl restart bluetooth.service 此时即可自动完成蓝牙设备的配对连接。 贴一个参考博客","categories":[],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"https://camel-zy.github.io/Camel_Blog/tags/ubuntu/"},{"name":"windows","slug":"windows","permalink":"https://camel-zy.github.io/Camel_Blog/tags/windows/"},{"name":"bluetooth","slug":"bluetooth","permalink":"https://camel-zy.github.io/Camel_Blog/tags/bluetooth/"}]},{"title":"CMake的使用基础","slug":"CMake的使用基础","date":"2022-04-23T05:14:41.000Z","updated":"2022-05-06T14:34:22.495Z","comments":true,"path":"2022/04/23/CMake的使用基础/","link":"","permalink":"https://camel-zy.github.io/Camel_Blog/2022/04/23/CMake%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80/","excerpt":"做C大程的时候研究了一下cmake的用法下面是CMakeLists.txt的基础写法","text":"做C大程的时候研究了一下cmake的用法下面是CMakeLists.txt的基础写法 以C大程所需的多文件结构为例 主目录下的CMakeLists.txt： 1234567891011121314151617181920212223242526272829303132# 最低版本号要求cmake_minimum_required(VERSION 3.0.0)# 项目名称project(Text_Editer VERSION 0.1.0)include(CTest)enable_testing()# 包含目录include_directories( $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/include/libgraphics $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/include/simpleGUI)aux_source_directory(. SRC_LIST)# 添加子目录add_subdirectory(include/libgraphics)add_subdirectory(include/simpleGUI)# 生成可执行文件add_executable(Text_Editer $&#123;SRC_LIST&#125;)# 链接target_link_libraries(Text_Editer libgraphics simpleGUI FileProcess GUI TextBox)set(CPACK_PROJECT_NAME $&#123;PROJECT_NAME&#125;)set(CPACK_PROJECT_VERSION $&#123;PROJECT_VERSION&#125;)include(CPack) 子目录下的CMakeLists.txt： 123456include_directories( $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/include/libgraphics $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/include/simpleGUI) # 注意如果子目录下的代码也需要include其他库的话 这里也需要include_directoriesaux_source_directory(. DIR_LIB_SRCS)add_library(libgraphics $&#123;DIR_LIB_SRCS&#125;)","categories":[],"tags":[{"name":"CMake","slug":"CMake","permalink":"https://camel-zy.github.io/Camel_Blog/tags/CMake/"}]},{"title":"C大程随性笔记","slug":"C大程随性笔记","date":"2022-02-22T14:31:04.000Z","updated":"2022-05-06T14:54:55.370Z","comments":true,"path":"2022/02/22/C大程随性笔记/","link":"","permalink":"https://camel-zy.github.io/Camel_Blog/2022/02/22/C%E5%A4%A7%E7%A8%8B%E9%9A%8F%E6%80%A7%E7%AC%94%E8%AE%B0/","excerpt":"一份C大程的随意笔记","text":"一份C大程的随意笔记 要是有哪里写错了那就写错了吧 反正考完理论考我也不用记这些东西了( enum关于枚举类型： 定义1enum TypeName&#123;ValueName1,ValueName2,...&#125;; 例如： 12enum week&#123; Mon = 1, Tues = 2, Wed = 3, Thurs = 4, Fri = 5, Sat = 6, Sun = 7 &#125; day; //内部用逗号分隔 最后为空 不是分号day = Mon; 对于没有赋值的元素，其值为前一元素加1 初值为0 例如 123enum Test &#123;x, y = 4, z&#125;;x == 0z == 5 typedef这边关于typedef再多记一点：对于数组的typedef 12typedef int vector[10];typedef int matrix[5][5]; 一个挺好的理解办法：去掉typedef就是变量定义。 联合（共同）体结构体分配足够的空间存储其所有成员，而共用体分配空间仅存储最大的成员。 例如 1234567union S &#123; char a; int b[4]; double c;&#125; x;sizeof(x) == 16 有一个“字节对齐问题” 例如 123456789union U&#123; char s[9]; int n; double d;&#125; x;sizeof(x) == 16 其中，s占9字节，n占4字节，d占8字节。但9既不能被4(int)整除，也不能被8(double)整除，因此补充字节到16。 union大小必须满足：1)大小足够容纳最宽的成员；2)大小能被其包含的所有基本数据类型的大小所整除。 指针普通指针函数形参有地址时，注意不要改变地址，只改变该地址指向的值以实现双向传输。放个错题： 12345void ArrayCreate(double **array, int size) &#123; array = (double **)malloc(sizeof(double *) * size); //wrong *array = (double *)malloc(sizeof(double) * size); //right&#125; 第一种改变会导致该参数的改变无法传出。(这玩意坑了我近两小时) 静态变量地址可返回使用（返回的指针指向的内存空间没有释放，在主调函数能够继续使用） 12345int * f4()&#123; static int d[10]; return d;&#125; 如果函数的返回类型是指针，则可以返回0。（NULL == 0） 使用前记得分配空间。 字符串指针两个字符串直接比较 比较的是首地址 12char *str = &quot;hello&quot;;str[0] = &#x27;H&#x27;; 这种写法不合法，str指针指向的是常量字符串，不允许修改，会导致段错误。 123char *color[5];for (int i = 0; i &lt; 5; i++) scanf(&quot;%s&quot;, color[i]); 这种写法亦不合法。段错误。 字符串数组的数组名不可修改 例如： 1234char color[ ][7] = &#123;&quot;red&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;green&quot;, “black&quot;&#125;;char * tmp = color[0]; color[0] = color[4]; color[4] = tmp; 编译错误！ 字符串处理相关函数(string.h库) 函数名 功能 int strcmp(const char *str1, const char *str2) 如果返回值小于 0，则表示 str1 小于 str2。 char *strcat(char *dest, const char *src) 把 src 所指向的字符串追加到 dest 所指向的字符串的结尾（dest会被修改）。返回一个指向最终的目标字符串 dest 的指针 char *strcpy(char *dest, const char *src) 把 src 所指向的字符串复制到 dest（dest会被修改），返回一个指向最终的目标字符串 dest 的指针。 函数指针顺带提一句，C语言不允许函数嵌套定义 即一个函数定义中不可以完整地包含另一个函数的定义。 定义函数返回类型(*指针变量名)(函数形参类型列表); 函数名代表函数的入口地址(常量)，是一个指针。通过函数指针可以调用函数，它也可以作为函数的参数。 放个栗子 1234567891011121314151617181920#include &lt;stdio.h&gt;int add(int num1,int num2)&#123; return num1 + num2;&#125;​​int sub(int num1,int num2)&#123; return num1 - num2;&#125;​​int calculate(int (*fp)(int,int),int num1,int num2)&#123; return (*fp)(num1,num2);&#125;​​int main()&#123; printf(&quot;3+5=%d\\n&quot;, calculate(add,3,5)); printf(&quot;3-5=%d\\n&quot;, calculate(sub,3,5));&#125; 数组指针12int *p[4];int (*p)[4]; 前者为指针数组，p先与[]结合代表其为数组。 后者为数组指针，p先与*结合代表其为指针，指向的为[4]数组。 一个小练习： 变量定义int *(*f[3])();中f是（ ） D A.一组指向返回int的函数的二级指针数组 B.一个指向一组返回int *的函数数组的指针 C.一个返回指向一组int *数组的指针的函数 D.一个返回int *的函数指针的数组 E.一个指向返回int *数组的函数的指针 F.一个指向一组返回int的函数指针的数组的指针 二维数组与指针放个栗子 对于以下程序，能够正确表示二维数组 t 的元素地址的表达式是(C) 123456789101112131415int main(void)&#123; int k, t[3][2], *pt[3]; for ( k = 0; k &lt; 3; k++) &#123; pt[k] = t[k]; &#125; return 0;&#125;A. &amp;t[3][2]B. *pt[0]C. *(pt+1)D. &amp;pt[2] 指针形参实参匹配二维数组名不是二级指针,而是一个数组指针。 即二维数组的每个元素都是一个一维数组。 放个栗子 感觉这很难说 也很无聊 12345678910下列哪些实参(左边)和形参(右边)能够匹配的是（DEFH）。A. double a[10][10] double **bB. double a[10][10] double b[][]C. double a[10][10] double b[10][]D. double a[10][10] double b[][10]E. double a[10][10] double (*b)[10]F. double *a[10] double **bG. double (*a)[10] double **bH. double **a double *b[]I. double **a double b[][] 另外注意有的时候需要对指针强制转换 比如void *很多时候需要转换。 文件指针 错误：文件指针指向文件缓冲区中文件数据的存取位置 文件指针实际上是指向一个结构体类型的指针，包含有诸如：缓冲区的地址在缓冲区中当前存取的字符的位置、对文件是“读”还是“写”、是否出错、是否已经遇到文件结束标志等信息。 fopen1FILE *fopen(const char *filename, const char *mode) 返回一个 FILE 指针。否则返回 NULL。 文件打开方式参数表： 参数 含义 r 只读（文件必须存在） w 只写（若文件不存在则新建） a 追写 r+ 读写（文件必须存在） w+ 读写（若文件不存在则新建） a+ 读/追写 加个b就是相应的二进制文件操作 懒得再赘述。 feof1int feof(FILE *stream) 文件结束：返回非0值；文件未结束：返回0值。 fputc1int fputc(int char, FILE *stream) 如果没有发生错误，则返回被写入的字符。如果发生错误，则返回 EOF。 rewind1void rewind(FILE *stream) 移到文件首。 ftell1long int ftell(FILE *stream) 返回位置标识符的当前值。如果发生错误，则返回 -1L。 fseek1int fseek(FILE *stream, long int offset, int whence) 参数： stream – 这是指向 FILE 对象的指针，该 FILE 对象标识了流。 offset – 这是相对 whence 的偏移量，以字节为单位。 whence – 这是表示开始添加偏移 offset 的位置。它一般指定为下列常量之一： 常量 描述 SEEK_SET 文件的开头 SEEK_CUR 文件指针的当前位置 SEEK_END 文件的末尾 ferror1int ferror(FILE *stream) 如果设置了与流关联的错误标识符，该函数返回一个非零值，否则返回一个零值。 fread1size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream) 成功读取的元素总数会以 size_t 对象返回。 参数： ptr – 这是指向带有最小尺寸 size*nmemb 字节的内存块的指针。 size – 这是要读取的每个元素的大小，以字节为单位。 nmemb – 这是元素的个数，每个元素的大小为 size 字节。 stream – 这是指向 FILE 对象的指针，该 FILE 对象指定了一个输入流。 fwrite1size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream) 参数： ptr – 这是指向要被写入的元素数组的指针。 size – 这是要被写入的每个元素的大小，以字节为单位。 nmemb – 这是元素的个数，每个元素的大小为 size 字节。 stream – 这是指向 FILE 对象的指针，该 FILE 对象指定了一个输出流。 如果成功，该函数返回一个 size_t 对象，表示元素的总数。 命令行参数main1int main(int argc, char *argv[]); argc为参数数量，argv为参数列表。文件名本身也算一个参数 所以argv[0]就是文件名 链表在单向链表中，头指针中存放的不是头结点的内容，头指针指向头结点。（都是些什么无聊的概念） 递归C语言规定，程序中各函数之间既允许直接递归调用也允许间接递归调用。 文件包含与工程文件放一道题： 12345678910在Dev-C++中创建工程P1，增加main函数所在的project.c，该工程需要使用libgraphics的linkedlist类库，关于linkedlist使用说明正确的有（ ）。 ADF A.通过文件包含将project.c和linkedlist.c连接成一个完整的可执行程序时，可以在project.c中#include &quot;linkedlist.c&quot;B.通过文件包含将project.c和linkedlist.c连接成一个完整的可执行程序时，可以在project.c中#include &quot;linkedlist.c&quot;，同时工程P1增加linkedlist.h和linkedlist.cC.通过工程文件将project.c和linkedlist.c连接成一个完整的可执行程序时，可以在project.c中#include &quot;linkedlist.h&quot;D.通过工程文件将project.c和linkedlist.c连接成一个完整的可执行程序时，可以在project.c中#include &quot;linkedlist.h&quot;，同时工程P1增加linkedlist.h和linkedlist.cE.通过文件包含将project.c和linkedlist.c连接成一个完整的可执行程序时，编译生成project.o和linkedlist.o，连接生成P1.exeF.通过工程文件将project.c和linkedlist.c连接成一个完整的可执行程序时，编译生成project.o和linkedlist.o，连接生成P1.exeB.重复包含 文件包含最终是单文件编译，相当于直接把包含的文件代码复制过来 而工程文件是需要编译连接 有的没的函数qsort1void qsort(void *base, size_t nitems, size_t size, int (*compar)(const void *, const void*)) 参数： base – 指向要排序的数组的第一个元素的指针。 nitems – 由 base 指向的数组中元素的个数。 size – 数组中每个元素的大小，以字节为单位。 compar – 用来比较两个元素的函数。 sprintf1int sprintf(char *str, const char *format, ...) 函数格式化输出成功，返回输出的字符数，不包括字符串结束符&#39;\\0&#39;，失败则返回一个负整数 形参str是指向输出缓冲区的指针，函数结束后，格式化的输出结果在缓冲区中，形参format的使用用法与函数printf的形参format相同 sscanf1int sscanf(const char *str, const char *format, ...) 形参s指定从中读取数据的字符串，形参format格式字符串，指定了输入的格式，并按照格式说明符解析输入对应位置的信息，并存储于可变参数列表中对应的指针所指位置，使用格式控制字符%n可以获取输入数据所消耗的字符数 格式化读取成功，返回读取的数据的个数（不包括%n哦），返回值为0表示没有将任何字段赋值，如果读入数据时遇到了“字符串结束”则返回EOF 例如： 123456char buffer[] = &quot;abc 5 6.7 cde&quot;;int a, m, n;char str[4];n = sscanf(buffer, &quot;%s %d%n&quot;, str, &amp;a, &amp;m);// m = 5, n = 2 一些已知宏NULL 0 EOF -1 奇奇怪怪的东西 正确：一般不能用任何一个文本编辑器打开二进制文件进行阅读。 malloc内存分配时记得强制转换 理论题里认为需要强制转换（虽然C语言允许省略 但C++不大行 register变量寄存器变量，其存储于寄存器，速度更快。 只有局部变量和形式参数才能定义为寄存器变量。 局部静态变量不能定义为寄存器变量，因为一个变量只能声明为一种存储类别。 寄存器的长度一般和机器的字长一致，所以，只有较短的类型如int、char、short等才适合定义为寄存器变量，诸如double等较大的类型，不推荐将其定义为寄存器类型。 CPU的寄存器数目有限，因此，即使定义了寄存器变量，编译器可能并不真正为其分配寄存器，而是将其当做普通的auto变量来对待，为其分配栈内存。当然，有些优秀的编译器，能自动识别使用频繁的变量，如循环控制变量等，在有可用的寄存器时，即使没有使用 register 关键字，也自动为其分配寄存器，无须由程序员来指定。 参考后面的函数相关笔记来自菜鸟教程","categories":[],"tags":[{"name":"c","slug":"c","permalink":"https://camel-zy.github.io/Camel_Blog/tags/c/"},{"name":"note","slug":"note","permalink":"https://camel-zy.github.io/Camel_Blog/tags/note/"}]},{"title":"新装Ubuntu后无Wi-Fi图标","slug":"新装Ubuntu后无Wi-Fi图标","date":"2022-02-05T04:31:00.000Z","updated":"2022-04-23T03:17:05.317Z","comments":true,"path":"2022/02/05/新装Ubuntu后无Wi-Fi图标/","link":"","permalink":"https://camel-zy.github.io/Camel_Blog/2022/02/05/%E6%96%B0%E8%A3%85Ubuntu%E5%90%8E%E6%97%A0Wi-Fi%E5%9B%BE%E6%A0%87/","excerpt":"安装Ubuntu后惊奇地发现莫的Wi-Fi","text":"安装Ubuntu后惊奇地发现莫的Wi-Fi 品牌: 天选2 (ASUS TUF Gaming A15 FA506QM_FA506QM) 网卡: MediaTek MT7921 OS: Ubuntu 20.04.3 LTS x86_64 问题:Ubuntu安装完成后，设置中无Wi-Fi选项卡，找不到无线网卡(好像没有驱动程序) 似乎只用在较新(2021.6)的电脑型号中会出现这类问题 解决：(这问题着实困扰了我很久，一直都没法正常使用Ubuntu 连不上Wi-Fi也用不了蓝牙 为适配最新硬件，需要将Linux内核升级到最新 刚完成安装的Ubuntu 20.04.3 使用的是5.11内核，无法正常支持MT7921网卡 因此需要自行更新内核版本(可能有一定风险) 可以暂时选择使用有线网络或者共享网络完成后续安装工作我使用的是手机USB共享网络 查询内核版本12uname -r5.11.0-36-generic 下载安装ubuntu-mainline-kernel.sh脚本12wget https://raw.githubusercontent.com/pimlie/ubuntu-mainline-kernel.sh/master/ubuntu-mainline-kernel.shsudo install ubuntu-mainline-kernel.sh /usr/local/bin/ 查看最新内核版本 1ubuntu-mainline-kernel.sh -c 查看所有可用内核版本 1sudo ubuntu-mainline-kernel.sh -r 安装新内核123sudo ubuntu-mainline-kernel.sh -i//或指定安装版本sudo ubuntu-mainline-kernel.sh -i 5.12.11 (亲测5.12.11版本内核仍无法解决问题 需要更新的内核版本) 在默认情况下 重启时系统会默认使用最新的内核 但也可以在启动系统时选择进入高级模式，指定所需要的内核 安装固件文件1sudo apt install linux-firmware 问题解决 不过注意关机后不要立即开机 等待半分钟到一分钟左右 不然两个系统都无法识别无线网卡(不知道为啥 但影响不大就不管它了) 参考资料https://miloserdov.org/?p=6899","categories":[],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"https://camel-zy.github.io/Camel_Blog/tags/ubuntu/"}]},{"title":"GPG相关笔记","slug":"GPG相关笔记","date":"2022-02-02T14:13:29.000Z","updated":"2022-02-05T05:01:02.060Z","comments":true,"path":"2022/02/02/GPG相关笔记/","link":"","permalink":"https://camel-zy.github.io/Camel_Blog/2022/02/02/GPG%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/","excerpt":"GPG相关笔记","text":"GPG相关笔记 GPG配置 12345678910gpg --gen-key //生成密钥对gpg --list-secret-keys --keyid-format LONG //列出密钥 包含keyidgpg -a -o public-file.key --export keyId //导出公钥 -a表示-armor,以ASCII码输出(默认以二进制输出)gpg -a -o secret-file.key --export keyId //导出私钥gpg --import .key //导入公钥或私钥gpg --delete-keys keyid //删除公钥gpg --delete-secret-keys //删除私钥gpg --recipient [用户ID] --output demo.en.txt --encrypt demo.txt //加密gpg demo.en.txt //解密gpg --verify demo.txt.asc demo.txt //验证签名 最后贴两个参考博客 http://ruanyifeng.com/blog/2013/07/gpg.html https://yexun1995.github.io/2020/09/15/GPG/","categories":[],"tags":[{"name":"gpg","slug":"gpg","permalink":"https://camel-zy.github.io/Camel_Blog/tags/gpg/"}]},{"title":"Ubuntu默认图片查看器打开jpg图片出错","slug":"Ubuntu默认图片查看器打开jpg图片出错","date":"2022-02-02T14:01:38.000Z","updated":"2022-04-23T15:22:50.163Z","comments":true,"path":"2022/02/02/Ubuntu默认图片查看器打开jpg图片出错/","link":"","permalink":"https://camel-zy.github.io/Camel_Blog/2022/02/02/Ubuntu%E9%BB%98%E8%AE%A4%E5%9B%BE%E7%89%87%E6%9F%A5%E7%9C%8B%E5%99%A8%E6%89%93%E5%BC%80jpg%E5%9B%BE%E7%89%87%E5%87%BA%E9%94%99/","excerpt":"图片文件无法打开问题","text":"图片文件无法打开问题 如图，打开图片文件时提示分析JPEG图像文件时出错(Not a JPEG file: starts with 0x89 0x50) 0x89 0x50开头的文件可能为png格式 只需将后缀名改为.png即可使用默认图片查看器打开","categories":[],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"https://camel-zy.github.io/Camel_Blog/tags/ubuntu/"}]},{"title":"Ubuntu下无法使用EasyConnect","slug":"Ubuntu下无法使用EasyConnect","date":"2022-02-02T13:59:40.000Z","updated":"2022-04-23T03:16:48.846Z","comments":true,"path":"2022/02/02/Ubuntu下无法使用EasyConnect/","link":"","permalink":"https://camel-zy.github.io/Camel_Blog/2022/02/02/Ubuntu%E4%B8%8B%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8EasyConnect/","excerpt":"EasyConnect问题","text":"EasyConnect问题 123456zhang-yue@zhang-yue:~$ /usr/share/sangfor/EasyConnect/EasyConnect Gtk-Message: 12:47:13.670: Failed to load module &quot;canberra-gtk-module&quot;(EasyConnect:26442): Pango-ERROR **: 12:47:13.802: Harfbuzz version too old (1.3.1)追踪与中断点陷阱 (核心已转储) 解决主要矛盾错误提示信息是Harfbuzz版本过旧，但这篇博客说其实是pango版本过新 所以需要降级pango 但又不能影响系统库 只需将相关依赖直接放在EasyConnect目录下 1234zhang-yue@zhang-yue:/usr/share/sangfor/EasyConnect$ ldd EasyConnect | grep pango libpangocairo-1.0.so.0 =&gt; /lib/x86_64-linux-gnu/libpangocairo-1.0.so.0 (0x00007f7fa0cee000) libpango-1.0.so.0 =&gt; /lib/x86_64-linux-gnu/libpango-1.0.so.0 (0x00007f7fa0b54000) libpangoft2-1.0.so.0 =&gt; /lib/x86_64-linux-gnu/libpangoft2-1.0.so.0 (0x00007f7f9eea9000) 不难发现，涉及到的so文件只有这么几个 只需到这里下载相关低版本依赖(按照这里的说法应该是低于1.42的版本即可) libpango-1.0-0_1.40.14-1ubuntu0.1_amd64.deb libpangocairo-1.0-0_1.40.14-1ubuntu0.1_amd64.deb libpangoft2-1.0-0_1.40.14-1ubuntu0.1_amd64.deb 解压后将***.so和***.so.***两个文件移入/usr/share/sangfor/EasyConnect/即可(这俩文件在解压后的data/usr/lib/x86_64-linux-gnu中) (听说似乎.so文件相当于windows的.dll文件) 还有一个小问题至此easyconnect总算是跑起来了 至少能看到图形界面了(心累) 然后就是来解决Failed to load module &quot;canberra-gtk-module&quot;的问题了 参考这里的方法 1sudo apt install libcanberra-gtk-module 芜湖 终于完事了(就是不知为何这玩意打开的速度有点慢)","categories":[],"tags":[{"name":"easyconnect","slug":"easyconnect","permalink":"https://camel-zy.github.io/Camel_Blog/tags/easyconnect/"},{"name":"ubuntu","slug":"ubuntu","permalink":"https://camel-zy.github.io/Camel_Blog/tags/ubuntu/"}]},{"title":"Ubuntu终端命令笔记","slug":"Ubuntu终端命令相关笔记","date":"2022-01-19T04:55:11.000Z","updated":"2022-05-06T14:38:10.182Z","comments":true,"path":"2022/01/19/Ubuntu终端命令相关笔记/","link":"","permalink":"https://camel-zy.github.io/Camel_Blog/2022/01/19/Ubuntu%E7%BB%88%E7%AB%AF%E5%91%BD%E4%BB%A4%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/","excerpt":"Ubuntu终端命令相关笔记","text":"Ubuntu终端命令相关笔记 系统相关硬件架构1234uname -aarch//x86_64 (听说x86_64,x64,AMD64基本上是同一个东西)","categories":[],"tags":[{"name":"note","slug":"note","permalink":"https://camel-zy.github.io/Camel_Blog/tags/note/"},{"name":"ubuntu","slug":"ubuntu","permalink":"https://camel-zy.github.io/Camel_Blog/tags/ubuntu/"}]},{"title":"Golang之旅","slug":"Golang之旅","date":"2022-01-19T03:42:14.000Z","updated":"2022-02-21T12:29:38.519Z","comments":true,"path":"2022/01/19/Golang之旅/","link":"","permalink":"https://camel-zy.github.io/Camel_Blog/2022/01/19/Golang%E4%B9%8B%E6%97%85/","excerpt":"Golang学习笔记","text":"Golang学习笔记 安装&amp;配置安装环境报错go安装环境报错： 1Installing github.com/uudashr/gopkgs/v2/cmd/gopkgs FAILED 解决： 12go env -w GO111MODULE=ongo env -w GOPROXY=https://goproxy.io,direct Go配置1sudo vim /etc/profile 在文件尾添加 123export GOPATH=/home/zhang-yue/工作路径export GOROOT=/usr/zhang-yue/go安装路径export PATH=$PATH:$GOROOT/bin:$GOPATH/bin 关闭后通过 12source /etc/profilego version 重启即可 Go语法基础下面开始快速入门golang(从入门到入坟) golang语句后不必加分号 包 每个Go程序都是由包构成 程序从main包开始运行。 在Go中，如果一个名字以大写字母开头，那么它就是可导出的。(例如fmt.Println P大写) 在导入一个包时，您只能引用已导出的名字，任何未导出的名字在该包外均无法访问 函数 声明格式 123func add(x,y int) int &#123; return x+y&#125; 注意：与C不同的是 Go在声明函数时函数返回值类型在最后 具体原因在这里 (主要是为了增加可读性吧) 函数可以有任意多的返回值 且返回值可被命名 对于没有参数的return语句 将直接返回已命名的返回值 在长程序中应避免直接返回 例如 1234func add(x,y int) (sum int) &#123; sum = x+y return&#125; 变量 在函数外必须使用var关键字声明变量 在函数内可使用:=简洁赋值语句代替var声明 与C不同的是，Go在不同类型变量间赋值时必须使用显式转换 常量 常量声明使用const关键字 常量可以是字符、字符串、布尔值或数值 常量不能用:=声明 数值常量是高精度的值 12345const ( Big = 1 &lt;&lt; 100 //Big的二进制是1后面跟着100个0 //直接输出将会溢出) 判断if 基本格式 123if x &lt; 0 &#123; //do something&#125; 与C不同的是:表达式外无需小括号 if语句可以在条件表达式前执行一个简单语句 该语句声明的变量作用域在if内 123if x := 5; x &lt; 10 &#123; //do something&#125; switch 基本格式 1234567891011121314151617181920package mainimport ( &quot;fmt&quot; &quot;runtime&quot;)func main() &#123; fmt.Print(&quot;Go runs on &quot;) switch os := runtime.GOOS; os &#123; case &quot;darwin&quot;: fmt.Println(&quot;OS X.&quot;) case &quot;linux&quot;: fmt.Println(&quot;Linux.&quot;) default: // freebsd, openbsd, // plan9, windows... fmt.Printf(&quot;%s.\\n&quot;, os) &#125;&#125; Go只运行选定的case，相当于在每个case后自动加了break但可使用fallthrough强制执行后续case case后无需为常量 取值不必为整数 case语句从上到下匹配 没有条件的switch相当于一长串的if-then-else 123456789101112131415161718package mainimport ( &quot;fmt&quot; &quot;time&quot;)func main() &#123; t := time.Now() switch &#123; case t.Hour() &lt; 12: fmt.Println(&quot;Good morning!&quot;) case t.Hour() &lt; 17: fmt.Println(&quot;Good afternoon.&quot;) default: fmt.Println(&quot;Good evening.&quot;) &#125;&#125; defer defer语句会将函数推迟到外层函数返回之后执行 但其参数会立即求值 推迟的函数调用会被压入一个栈中 在外层函数返回后按照后进先出顺序调用 循环for 基本格式 123for i:=0; i&lt;10; i++ &#123; sum += i&#125; 与C语言不同，Go的for语句后的三个部分外没有小括号 “while” C的while在Go中叫做for 基本格式 123for sum&lt;1000 &#123; sum += sum&#125; 在”while”条件前后加上两个分号即为标准的for语句 123for ;sum&lt;1000; &#123; sum += sum&#125; 无限循环 只需省略循环条件 123for &#123;&#125; 结构体 结构体指针允许隐式间接引用(这是什么鬼话 看下面例子 例如 有一个指向结构体的指针p 那么在C语言中可以通过(*p).X来访问其字段X 在go中允许通过p.x来访问 这边放一个结构体的例子用来看语法 123456789101112131415161718package mainimport &quot;fmt&quot;type Vertex struct &#123; X, Y int&#125;var ( v1 = Vertex&#123;1, 2&#125; // 创建一个 Vertex 类型的结构体 v2 = Vertex&#123;X: 1&#125; // Y:0 被隐式地赋予 v3 = Vertex&#123;&#125; // X:0 Y:0 p = &amp;Vertex&#123;1, 2&#125; // 创建一个 *Vertex 类型的结构体（指针）)func main() &#123; fmt.Println(v1, p, v2, v3)&#125; 数组与切片 数组声明 1var a [10]int 切片声明 123 primes := [6]int&#123;2, 3, 5, 7, 11, 13&#125;var s []int = primes[1:4] 切片提供动态大小 例中1:4为半开区间 左闭右开 切片不存储任何数据 更改切片会修改底层数组 切片拥有长度和容量。 切片的长度就是它所包含的元素个数。 切片的容量是从它的第一个元素开始数，到其底层数组元素末尾的个数。 切片 s 的长度和容量可通过表达式len(s)和cap(s)来获取。 12345678910111213141516 func main() &#123;s := []int&#123;2, 3, 5, 7, 11, 13&#125; //len=6 cap=6 [2 3 5 7 11 13]// 截取切片使其长度为 0s = s[:0] //len=0 cap=6 []// 拓展其长度s = s[:4] //len=4 cap=6 [2 3 5 7]// 舍弃前两个值s = s[2:] //len=2 cap=4 [5 7] &#125; 拓展长度时超过容量会引发panic 切片的零值为nil 123456- 可用make函数创建切片 ```go a := make([]int, 5) //len(a)=5 a := make([]int, 0, 5) //len(a)=0,cap(a)=5 切片可包含任意类型 切片的切片 1234567891011121314151617181920212223242526package mainimport ( &quot;fmt&quot; &quot;strings&quot;)func main() &#123; // 创建一个井字板（经典游戏） board := [][]string&#123; []string&#123;&quot;_&quot;, &quot;_&quot;, &quot;_&quot;&#125;, []string&#123;&quot;_&quot;, &quot;_&quot;, &quot;_&quot;&#125;, []string&#123;&quot;_&quot;, &quot;_&quot;, &quot;_&quot;&#125;, &#125; // 两个玩家轮流打上 X 和 O board[0][0] = &quot;X&quot; board[2][2] = &quot;O&quot; board[1][2] = &quot;X&quot; board[1][0] = &quot;O&quot; board[0][2] = &quot;X&quot; for i := 0; i &lt; len(board); i++ &#123; fmt.Printf(&quot;%s\\n&quot;, strings.Join(board[i], &quot; &quot;)) &#125;&#125; Panic参考博客 1234567891011121314package mainimport ( &quot;fmt&quot; &quot;errors&quot;)func main() &#123; fmt.Println(&quot;Enter function main.&quot;) panic(errors.New(&quot;something wrong&quot;)) // 引发 panic p := recover() fmt.Printf(&quot;panic: %s\\n&quot;, p) fmt.Println(&quot;Exit function main.&quot;)&#125; 此程序recover()不会执行 引发panic后(控制权会沿着调用栈反方向传播)，后续程序不再执行 正确用法 12345678910111213141516171819202122232425package mainimport ( &quot;fmt&quot; &quot;errors&quot;)func main() &#123; fmt.Println(&quot;Enter function main.&quot;) defer func()&#123; fmt.Println(&quot;Enter defer function.&quot;) if p := recover(); p != nil &#123; fmt.Printf(&quot;panic: %s\\n&quot;, p) &#125; fmt.Println(&quot;Exit defer function.&quot;) &#125;() panic(errors.New(&quot;something wrong&quot;)) // 引发 panic。 fmt.Println(&quot;Exit function main.&quot;)&#125;//运行结果Enter function main.Enter defer function.panic: something wrongExit defer function. 当一个函数即将结束执行时，写在最下面的defer函数调用会最先执行，其次是写在它上边的与它距离最近的defer函数调用，以此类推。 12345678910111213141516171819package mainimport &quot;fmt&quot;func main() &#123; defer fmt.Println(&quot;first defer&quot;) for i := 0; i &lt; 3; i++ &#123; defer fmt.Printf(&quot;defer in for [%d]\\n&quot;, i) &#125; defer fmt.Println(&quot;last defer&quot;)&#125;//运行结果last deferdefer in for [2]defer in for [1]defer in for [0]first defer swagger-UI 相关编写完注释后记得运行以下swag init来生成接口文档数据(忘了两次了) 安装swag:go get -u github.com/swaggo/swag/cmd/swag","categories":[],"tags":[{"name":"note","slug":"note","permalink":"https://camel-zy.github.io/Camel_Blog/tags/note/"},{"name":"golang","slug":"golang","permalink":"https://camel-zy.github.io/Camel_Blog/tags/golang/"}]},{"title":"美化Ubuntu","slug":"美化Ubuntu","date":"2022-01-14T15:22:09.000Z","updated":"2022-01-15T14:20:13.676Z","comments":true,"path":"2022/01/14/美化Ubuntu/","link":"","permalink":"https://camel-zy.github.io/Camel_Blog/2022/01/14/%E7%BE%8E%E5%8C%96Ubuntu/","excerpt":"默认的主题有点丑 需要亿点点美化","text":"默认的主题有点丑 需要亿点点美化 gnome安装相关工具 123sudo apt install gnome-tweak-toolsudo apt install gnome-shell-extensionssudo apt install chrome-gnome-shell gnome官方插件中心 打开 1gnome-tweaks 重启gnome只需alt+F2 输入r即可 插件 dash to dock 更改dock栏 需隐藏原有dock栏 12cd /usr/share/gnome-shell/extensionssudo mv ubuntu-dock@ubuntu.com ../ 主题GTK Theme: 构建应用程序的图形用户界面的框架 Gnome Shell Theme: Shell元素主题 gnome主题下载 Canta theme","categories":[],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"https://camel-zy.github.io/Camel_Blog/tags/ubuntu/"},{"name":"gnome","slug":"gnome","permalink":"https://camel-zy.github.io/Camel_Blog/tags/gnome/"}]},{"title":"博客搭建","slug":"博客搭建","date":"2022-01-12T04:04:20.000Z","updated":"2022-01-26T03:48:57.313Z","comments":true,"path":"2022/01/12/博客搭建/","link":"","permalink":"https://camel-zy.github.io/Camel_Blog/2022/01/12/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/","excerpt":"使用linux时发现乱七八糟的指令有点多，所以搞了个博客来记录一下下。","text":"使用linux时发现乱七八糟的指令有点多，所以搞了个博客来记录一下下。 相关软件安装添加nodejs源 1sudo curl -sL https://deb.nodesource.com/setup_14.x | sudo -E bash - 安装node.js 1sudo apt install nodejs 安装hexo(-g为全局安装) 1sudo npm install -g hexo 本地创建博客初始化创建 12hexo initnpm install 清除所有记录 1hexo clean 生成静态网页 1hexo generate 启动服务(-p表示端口 默认4000) 1hexo server -p 80 主题配置下载的主题放在themes中并将_config.yml中theme:后的名字改掉 123hexo cleanhexo generatehexo server 上传到gitee在_config.yml补充deploy部分 1234deploy: type: git repo: git@gitee.com:Zhang_Yue0621/camel_blog.git #仓库的地址 branch: master 安装插件 1npm install hexo-deployer-git --save 上传！ 1hexo deploy hexo常用命令整理12345hexo new &quot;postname&quot; #新建文章hexo new page &quot;pagename&quot; #新建页面hexo d #上传 等价于hexo deploy hexo g #生成静态网页 等价于hexo generate hexo s #本地部署 等价于hexo server 撰写博客摘要和正文使用&lt;!--more--&gt;隔开标签使用如下形式 1234tags: - hexo - fluid - blog 插入图片打开根目录下_config.yml 将post_asset_folder改为true 此时每次新建文章时将会自动创建同名文件夹用于存放图片 安装插件npm install hexo-asset-img 使用hexo-asset-image插件时转换后的地址错误 无法使用 几经周折后发现了hexo-asset-img插件可以正常工作 写博客时只需根据markdown语法![title](xxx.png)即可 参考博客 github地址 参考链接搭建博客 fluid主题 主题配置","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://camel-zy.github.io/Camel_Blog/tags/hexo/"},{"name":"fluid","slug":"fluid","permalink":"https://camel-zy.github.io/Camel_Blog/tags/fluid/"},{"name":"blog","slug":"blog","permalink":"https://camel-zy.github.io/Camel_Blog/tags/blog/"}]},{"title":"C小程错题整理","slug":"C小程错题整理","date":"2022-01-07T05:24:33.000Z","updated":"2022-04-23T15:23:24.938Z","comments":true,"path":"2022/01/07/C小程错题整理/","link":"","permalink":"https://camel-zy.github.io/Camel_Blog/2022/01/07/C%E5%B0%8F%E7%A8%8B%E9%94%99%E9%A2%98%E6%95%B4%E7%90%86/","excerpt":"C小程的错题整理","text":"C小程的错题整理 判断 C程序中定义的变量，代表内存中的一个存储单元。 True 执行以下程序段，sum的值是55。 False 1234int i, sum;for (i = 1; i &lt;= 10; i++)&#123; sum = sum + i;&#125; C语言中的所有语句都必须以分号结束。 True 若变量已正确定义，执行以下while语句将陷入死循环。 False 123i = 1;while (i &lt;= 10) ; i++; 以下程序段的功能是输出1～100之间每个整数的各位数字之和。 False(死循环) 12345678for(num = 1; num &lt;= 100; num++)&#123; s = 0; do&#123; s = s + num % 10; num = num / 10; &#125;while(num != 0); printf(&quot;%d\\n&quot;, s); &#125; 08是正确的整型常量。 False 表达式~(~2&lt;&lt;1)的值是5。 True 表达式(z=0, (x=2)||(z=1),z)的值是1。 False 运算符“+”不能作为单目运算符。 False 自动变量如果没有赋值，其值被自动赋为0。 False （auto != statics) 为了检查以下省略else的if语句的分支是否正确，至少需要设计3组测试用例，即grade的取值至少有三组（小于、大于、等于60）。 123if(grade &lt; 60)&#123; printf(&quot;Fail\\n&quot;); &#125; True (需检查边界值) C语言中，大小写字母&#39;A&#39;，&#39;B&#39;，&#39;C&#39;，…，&#39;Z&#39; ，&#39;a&#39;，&#39;b&#39;，&#39;c&#39;，…，&#39;z&#39;的ASCII码按升序连续排列。 False (连续?) 设变量已正确定义，执行以下程序段，顺序输入三个字符&#39;Q&#39;，则输出Q。 12ch = getchar(); putchar(ch); False (三个字符&#39;Q&#39;) 一维数组定义的一般形式如下： 1类型名 数组名[数组长度]； 数组元素引用的一般形式如下： 1数组名[下标] 在引用数组元素时，下标的合理取值范围是[0，数组长度-1]，下标不能越界。 True 二维数组定义的一般形式如下，其中的类型名指定数组名的类型。 1类型名 数组名[行长度][列长度]； False (类型名指定数组中每个元素的类型) 二维数组定义的一般形式如下，其中的行长度和列长度都是整型常量表达式。 1类型名 数组名[行长度] [列长度]； True (允许空格、换行) 引用二维数组的元素要指定两个下标，即行下标和列下标，一般形式如下。 1数组名[列下标][行下标] False 假设结构指针p已定义并正确赋值，其指向的结构变量有一个成员是int型的num，则语句*p.num = 100; 是正确的。 False(优先级) 表达式 (z=0, (x=2)||(z=1),z) 的值是1。 False(短路) 运行包含以下代码段的程序将可能进入死循环。 12int i = 1；while(i&gt;0)&#123; i++; printf(&quot;%d &quot;,i); &#125; False(溢出) 选择 (多)以下程序段（ ）的功能是：输入一批整数，用负数作为输入的结束标志，统计其中大于85的数据个数。 AD 123456789101112131415161718192021222324252627282930313233343536373839A. int count = 0, score; scanf (&quot;%d&quot;, &amp;score); while(score &gt;= 0)&#123; if(score &gt; 85)&#123; count++; &#125; scanf (&quot;%d&quot;, &amp;score); &#125; printf(&quot;%d\\n&quot;, count);B. int count = 0, score; scanf (&quot;%d&quot;, &amp;score); while(score &gt;= 0)&#123; scanf (&quot;%d&quot;, &amp;score); if(score &gt; 85)&#123; count++; &#125; &#125; printf(&quot;%d\\n&quot;, count);C. int count = 0, score; while(score &gt;= 0)&#123; scanf (&quot;%d&quot;, &amp;score); if(score &gt; 85)&#123; count++; &#125; &#125; printf(&quot;%d\\n&quot;, count);D. int count = 0, score; while(1)&#123; scanf (&quot;%d&quot;, &amp;score); if(score &lt; 0) break; if(score &gt; 85)&#123; count++; &#125; &#125; printf(&quot;%d\\n&quot;, count); 下面的程序段输出是（ ）。 D 1234567int k=11;printf(&quot;k=%d,k=%o,k=%x\\n&quot;,k,k,k);A.k=11,k=12,k=11B.k=11,k=13,k=13C.k=11,k=013;k=0xbD.k=11,k=13,k=b 下面的程序段输出是（ ）。 B 123456789short int a;int b = 65536;a = b;printf(&quot;%d\\n&quot;, a);A.65536B.0C.-1D.1 阅读以下程序段，如果从键盘上输入1234567&lt;回车&gt;，则程序的运行结果是（ ）。 D 12345678int i,j;scanf(&quot;%3d%2d&quot;,&amp;i,&amp;j);printf(&quot;i = %d, j = %d\\n&quot;,i,j);A.i = 123, j = 4567B.i = 1234, j = 567C.i = 1, j = 2D.i = 123, j = 45 阅读以下程序段，如果从键盘上输入abc&lt;回车&gt;，则程序的运行结果是（ ）。A 12345678char ch;scanf(&quot;%3c&quot;,&amp;ch);printf(&quot;%c&quot;,ch);A.aB.bC.cD.语法出错 已知字符&#39;A&#39;的ASCII码是65，分别对应八进制数101和十六进制数41，以下（ ）不能正确表示字符’A’。 D 1234A.&#x27;A&#x27;B.&#x27;\\101&#x27;C.&#x27;\\x41&#x27;D.&#x27;\\0x41&#x27; 设以下变量均为int类型，表达式的值不为9的是（）。 C 1234A.(x = y = 8, x+y, x+1)B.(x = y = 8, x+y, y+1)C.(x = 8, x+1, y = 8, x+y)D.(y = 8, y+1, x = y, x+1) 运算符（ ）的优先级最高。 A 1234A.[ ]B.+=C.? :D.++ 执行下面程序中的输出语句后，输出结果是（ ）。 B 1234567int a;printf(&quot;%d\\n&quot;,(a=3*5,a*4,a+5));A.65B.20C.15D.10 以下关于函数叙述中，错误的是（ ）。 B (不定参函数，隐式转换) A.函数未被调用时，系统将不为形参分配内存单元 B.实参与形参的个数必须相等，且实参与形参的类型必须对应一致 C.当形参是变量时，实参可以是变量、常量或表达式 D.如函数调用时，实参与形参都为变量，则这两个变量不可能占用同一内存空间 (多)对于以下两个程序段，下列叙述正确的是（ ）。 ACF A.在程序段1和程序段2中，语句y = x + 1;的执行条件皆为满足x&lt;1。 B.在程序段1和程序段2中，语句y = x + 1;的执行条件皆为满足x&lt;2。 C.在程序段1中，语句y = x + 2;的执行条件是满足x&gt;=2。 D.在程序段1中，语句y = x + 2;的执行条件是满足x&gt;=1且x&lt;2。 E.在程序段2中，语句y = x + 2;的执行条件是满足x&gt;=2。 F.在程序段2中，语句y = x + 2;的执行条件是满足x&gt;=1且x&lt;2。 1234567891011121314151617/ * 程序段1 */if (x &lt; 2)&#123; if (x &lt; 1)&#123; y = x + 1; &#125;&#125;else&#123; y = x + 2;&#125;/ * 程序段2 */if (x &lt; 2)&#123; if (x &lt; 1)&#123; y = x + 1; &#125;else&#123; y = x + 2; &#125;&#125; (多)设变量已正确定义，以下（）是合法的switch语句。 ACD 12345678910111213141516171819202122232425262728293031323334A.switch(op)&#123; default: printf(&quot;Error\\n&quot;); break;&#125;B.switch(op)&#123; case &#x27;*&#x27;: printf(&quot;%d\\n&quot;, value1 * value2); break; case &#x27;+&#x27;: printf(&quot;%d\\n&quot;, value1 + value2); break; case &#x27;-&#x27;: printf(&quot;%d\\n&quot;, value1 - value2); break; case &#x27;*&#x27;: printf(&quot;%d\\n&quot;, value1 * value2); break; default: printf(&quot;Error\\n&quot;); break;&#125;C.switch(&#x27;/&#x27;)&#123; case &#x27;*&#x27;: printf(&quot;%d\\n&quot;, value1 * value2); break; case &#x27;-&#x27;: printf(&quot;%d\\n&quot;, value1 - value2); break; case &#x27;+&#x27;: printf(&quot;%d\\n&quot;, value1 + value2); break; default: printf(&quot;Error\\n&quot;); break;&#125;D.switch(op+1)&#123; default: printf(&quot;Error\\n&quot;); break; case &#x27;*&#x27;: printf(&quot;%d\\n&quot;, value1 * value2); break; case &#x27;+&#x27;: printf(&quot;%d\\n&quot;, value1 + value2); break;&#125;E.switch(op)&#123; case op == &#x27;+&#x27;: printf(&quot;%d\\n&quot;, value1 + value2); break; default: printf(&quot;Error\\n&quot;); break;&#125; (多)设变量已正确定义，以下（）是合法的C语句。 AC 12345678910111213141516171819202122232425A.if ( n &lt;= 10 );B.switch ( k ) &#123; case 1: printf(&quot;one&quot;); break; case 2: printf(&quot;two&quot;); break; case 1: printf(&quot;one&quot;); break; default: printf(&quot;zero&quot;); break;&#125;C.switch ( k%2 ) &#123; default: printf(&quot;zero&quot;); break; case 1: printf(&quot;one&quot;); case 1+1: printf(&quot;two&quot;);&#125;D.n = 10;switch ( k ) &#123; case n%3: printf(&quot;one&quot;); case n%4: printf(&quot;two&quot;); default: printf(&quot;zero&quot;);&#125; (多)选项（ ）与以下字符数组定义等价。 ABD 123456static char s[6] = &#123;&#x27;H&#x27;, &#x27;a&#x27;, &#x27;p&#x27;, &#x27;p&#x27;, &#x27;y&#x27;, &#x27;\\0&#x27;&#125;;A.static char s[6] = &#123;&#x27;H&#x27;, &#x27;a&#x27;, &#x27;p&#x27;, &#x27;p&#x27;, &#x27;y&#x27;&#125;;B.static char s[6] =&quot;Happy&quot;;C.static char s[6] =&#123;&quot;Happy&quot;&#125;;D.static char s[6] = &#123;&#x27;H&#x27;, &#x27;a&#x27;, &#x27;p&#x27;, &#x27;p&#x27;, &#x27;y&#x27;, 0&#125;; 以下能正确定义数组并正确赋初值的语句是（）。 D C中改为int c[][2]=&#123;&#123;1,2&#125;,&#123;3,4&#125;&#125;则可 1234A.int N=5, b[N][N];B.int a[1][2]=&#123;&#123;1&#125;, &#123;3&#125;&#125;;C.int c[2][ ]=&#123;&#123;1, 2&#125;, &#123;3, 4&#125;&#125;;D.int d[3][2]=&#123;&#123;1, 2&#125;, &#123;34&#125;&#125;; 以下选项中，对基本类型相同的指针变量不能进行运算的运算符是 ( )。 A 指针相加无意义 相减为两指针相隔元素数 A.+ B.- C.= D.== 对于以下程序段，则叙述正确的是（ ）。 D 123char s[ ]=&quot;china&quot;; char *p; p = s; A.s和p完全相同 B.数组s中的内容和指针变量p中的内容相等 C.数组s的长度和p所指向的字符串长度相等 D.*p与s[0]相等 对于以下定义，错误的scanf函数调用语句是（）。 A 12345678910111213struct pupil&#123; char name[20]; int age; int sex;&#125;pup[5];A.scanf(&quot;%s&quot;, &amp;pup[0].name);B.scanf(&quot;%d&quot;, &amp;pup[1].age);C.scanf(&quot;%d&quot;, &amp;pup[2].sex);D.scanf(&quot;%s&quot;, pup[4].name); 以下程序的输出结果是（ ）。 C 1234567891011121314struct stu&#123; int x; int *y;&#125; *p;int dt[4] = &#123;10, 20, 30, 40&#125;;struct stu a[4] = &#123;50, &amp;dt[0], 60, &amp;dt[1], 70, &amp;dt[2], 80, &amp;dt[3]&#125;;int main( )&#123; p=a; printf(&quot;%d,&quot;, ++p-&gt;x); printf(&quot;%d,&quot;, (++p)-&gt;x); printf(&quot;%d&quot;, ++(*p-&gt;y)); return 0;&#125; A.10,20,20 B.50,60,21 C.51,60,21 D.60,70,31 对于以下结构定义，(*p)-&gt;str++中的++加在（）。 D 1234struct &#123; int len; char *str&#125; *p; A.指针str上 B.指针p上 C.str指向的内容上 D.语法错误 在“文件包含”预处理语句的使用过程中，当#include后面的文件名用双引号括起来时，寻找被包含文件的方式是( )。 B(用&lt;&gt;时选A) A.直接按系统设定的标准方式搜索目录 B.先在源程序所在目录搜索，再按系统设定的标准方式搜索 C.仅仅搜索源程序所在目录 D.仅仅搜索当前目录 下面说法中正确的是（）。 A(题目可能存在问题) A.若全局变量仅在单个C文件中访问，则可以将这个变量修改为静态全局变量，以降低模块间的耦合度 B.若全局变量仅由单个函数访问，则可以将这个变量改为该函数的静态局部变量，以降低模块间的耦合度 C.设计和使用访问动态全局变量、静态全局变量、静态局部变量的函数时，需要考虑变量生命周期问题 D.静态全局变量使用过多，可那会导致动态存储区（堆栈）溢出 (B选项：仅仅由单个函数访问，不存在模块耦合度问题 C选项：动态全局变量，静态全局变量，静态局部变量的生命周期都是整个程序运行期间，跟函数设计没有关系 D选项：静态全局变量存储于全局（静态）数据区) 若fopen()函数打开文件失败，其返回值是（ ）。 C(成功返回file地址) A.1 B.-1 C.NULL D.ERROR 若读文件还未读到文件末尾， feof()函数的返回值是（ ）。 B(结束为1) A.-1 B.0 C.1 D.非0 fputc(ch,fp) 把一个字符ch写到fp所指示的磁盘文件中，若写文件失败则函数的返回值为（ ）。 C(成功为ch) A.0 B.1 C.EOF D.非0 缓冲文件系统的文件缓冲区位于（）。 C A.磁盘缓冲区中 B.磁盘文件中 C.内存数据区中 D.程序文件中 直接使文件指针重新定位到文件读写的首地址的函数是（） 。 C A.ftell() B.fseek() C.rewind() D.ferror() 填空 若变量已正确定义，执行以下程序段，并回答下列问题。请注意，直接填数字，前后不要加空格等任何其他字符。 1234i = 1;while (i &lt;= 10) i++; /* 语句① */ printf(&quot;%d\\n&quot;, i); /* 语句② */ 语句①执行了?次 语句②执行了?次 循环体语句共执行了?次 当循环结束时，变量i的值是? 10 1 10 11 若变量已正确定义，写出以下程序段的运行结果。 12345scanf (&quot;%d&quot;, &amp;k); while(k &gt;= 0)&#123; scanf (&quot;%d&quot;, &amp;k); printf(&quot;%d#&quot;, k); &#125; 输入1 2 3 0 -1，输出 输入1 0 2 3 -1，输出 输入1 2 3 -1 9，输出 2#3#0#-1# 0#2#3#-1# 2#3#-1# 若变量已正确定义，写出以下程序段的运行结果。 123456789scanf (&quot;%d&quot;, &amp;m);limit = sqrt(m) + 1;for(i = 2; i &lt;= limit; i++)&#123; if(m % i == 0)&#123; printf(&quot;No&quot;); &#125;else&#123; printf(&quot;Yes&quot;); &#125;&#125; 输入9，输出 输入4，输出 YesNoYes NoYes 写出以下程序的运行结果。请注意，直接填数字或者字符，前、后和中间不要加空格。 123456789101112131415#include &lt;stdio.h&gt;int main(void)&#123; int c1 = 0, c2 = 0; char ch; while((ch = getchar()) != &#x27;#&#x27;)&#123; switch(ch)&#123; case &#x27;a&#x27;: case &#x27;h&#x27;: c1++; default: c2++; &#125; &#125; printf(&quot;c1=%d,c2=%d\\n&quot;, c1, c2); /* 中间、前、后都没有空格 */ return 0;&#125; 输入china#，输出（） c1=2,c2=5 写出以下程序段的运行结果。请注意，直接填单词、字符或者两者的组合，前后不要加空格等任何其他字符。 123456double grade; scanf (&quot;%lf&quot;, &amp;grade); if(grade &lt; 60); &#123; printf(&quot;Fail&quot;); &#125;printf(&quot;?&quot;); 输入50，输出 输入60，输出 输入90，输出 Fail? Fail? Fail? 假设整型数据用两个字节表示，则用二进制表示-127的原码为？反码为？补码为？ 1000000001111111 1111111110000000 1111111110000001 以下程序的运行结果是 12345678910111213#include&lt;stdio.h&gt;struct ps&#123; double i; char arr[24];&#125;;int main()&#123; struct ps s[3], *p1, *p2; p1=s; p2=s+2; printf(&quot;%d,%d\\n&quot;, p2-p1, sizeof(struct ps)); /* 输出数据之间没有空格分隔 */return 0;&#125; 2,32 以下程序的运行结果是 12345678910111213141516171819202122232425#include &lt;stdio.h&gt;struct st&#123;char c; char s[80];&#125;;struct st a[4] = &#123;&#123;&#x27;1&#x27;,&quot;123&quot;&#125;, &#123;&#x27;2&#x27;,&quot;321&quot;&#125;, &#123;&#x27;3&#x27;,&quot;123&quot;&#125;, &#123;&#x27;4&#x27;,&quot;321&quot;&#125;&#125;;char * f(struct st *t);int main( )&#123; int k; for(k = 0; k &lt; 4; k++)&#123; printf(&quot;%s&quot;, f(a+k)); &#125; return 0;&#125;char * f(struct st *t)&#123; int k = 0; while(t-&gt;s[k] != &#x27;\\0&#x27;)&#123; if( t-&gt;s[k] == t-&gt;c)&#123; return t-&gt;s+k; &#125; k++; &#125; return t-&gt;s;&#125; 123213321 运行以下程序段，第1行输出?，第2行输出? 12345678910111213struct &#123; int a; int *b;&#125; s[4], *p;int i, n = 1; for(i = 0; i &lt; 4; i++)&#123; s[i].a = n; s[i].b = &amp;s[i].a; n = n + 2;&#125;p = &amp;s[0];printf(&quot;%d\\n&quot;, ++*p-&gt;b);p++;printf(&quot;%d,%d\\n&quot;, (++p)-&gt;a, (p++)-&gt;a); /* 输出数据之间没有空格分隔 */ 2 7,3 (printf从右向左计算) ```C printf(“%.3lf\\n”, 2.0/3); 12345678910111213141516171819 输出： 0.667 (会四舍五入)- 阅读以下程序并回答问题。 ```C #include &lt;stdio.h&gt; void f2(int n) &#123; int s = 0; while(n--)&#123; s += n; &#125; printf(&quot;%d,%d\\n&quot;, n, s); /* 中间没有空格 */ &#125; int main(void) &#123; f2(4); return 0; &#125; 输出： -1,6(not 4,6) 阅读以下程序并回答问题。 1234567891011121314151617#include &lt;stdio.h&gt;int f2() &#123; static int k = 1, s; s = s + k; k++; return s;&#125;int main(void)&#123; int i; for(i = 1; i &lt;= 3; i++)&#123; f2(); &#125; printf(&quot;%d\\n&quot;, f2()); return 0;&#125; 输出： 10(not 4) //静态变量不会重新赋初值 根据数据存储的编码形式，C语言中处理的数据文件通常为?文件和?文件两种。 C语言中，在成功打开一个文件后，可以使用?来获取文件缓冲区的FILE结构信息。 fgets(s,n,fp);语句用来从fp所指示的文本文件中读取字符串s，该语句最多读取?个字符。 n-1 零零散散 逗号表达式 从左到右计算，返回值为最后一个表达式的值 取反后需转为原码 如对10取反为-11 strcpy() 后面字符串复制到前面字符串 覆盖 文件打开参数 https://www.cnblogs.com/kangjianwei101/p/5220021.html 实数存储方式 符号 阶码(移码表示的乘幂指数) 尾数 没有基数(乘幂的底数) 二维指针 *(*(p+1)+1) 表示p[1][1] 指针数组和数组指针 int *p1[5] 每个元素都是指针 int (*p2)[5] 一个指向数组的指针 sizeof()表达式的值在编译时确定。编译器不计算其中表达式的值，仅将其替换为对应类型。 scanf遇到空白字符截止，为输入一行可使用 scanf(“[^\\n]”,str) 或gets()。 注意：scanf(“%s”, s)输入 “How are you?” 遇到空格截断，只得到How。 位运算是根据内存中的二进制位进行运算的 true false等不是保留关键字 左移运算符&lt;&lt;用来把操作数的各个二进制位全部左移若干位，高位丢弃，低位补0。 右移运算符&gt;&gt;用来把操作数的各个二进制位全部右移若干位，低位丢弃，高位补 0 或 1。如果数据的最高位是 0，那么就补 0；如果最高位是 1，那么就补 1。 补个优先级表格","categories":[],"tags":[{"name":"C","slug":"C","permalink":"https://camel-zy.github.io/Camel_Blog/tags/C/"}]}],"categories":[],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://camel-zy.github.io/Camel_Blog/tags/Ubuntu/"},{"name":"ubuntu","slug":"ubuntu","permalink":"https://camel-zy.github.io/Camel_Blog/tags/ubuntu/"},{"name":"note","slug":"note","permalink":"https://camel-zy.github.io/Camel_Blog/tags/note/"},{"name":"sqlmap","slug":"sqlmap","permalink":"https://camel-zy.github.io/Camel_Blog/tags/sqlmap/"},{"name":"github","slug":"github","permalink":"https://camel-zy.github.io/Camel_Blog/tags/github/"},{"name":"script","slug":"script","permalink":"https://camel-zy.github.io/Camel_Blog/tags/script/"},{"name":"windows","slug":"windows","permalink":"https://camel-zy.github.io/Camel_Blog/tags/windows/"},{"name":"bluetooth","slug":"bluetooth","permalink":"https://camel-zy.github.io/Camel_Blog/tags/bluetooth/"},{"name":"CMake","slug":"CMake","permalink":"https://camel-zy.github.io/Camel_Blog/tags/CMake/"},{"name":"c","slug":"c","permalink":"https://camel-zy.github.io/Camel_Blog/tags/c/"},{"name":"gpg","slug":"gpg","permalink":"https://camel-zy.github.io/Camel_Blog/tags/gpg/"},{"name":"easyconnect","slug":"easyconnect","permalink":"https://camel-zy.github.io/Camel_Blog/tags/easyconnect/"},{"name":"golang","slug":"golang","permalink":"https://camel-zy.github.io/Camel_Blog/tags/golang/"},{"name":"gnome","slug":"gnome","permalink":"https://camel-zy.github.io/Camel_Blog/tags/gnome/"},{"name":"hexo","slug":"hexo","permalink":"https://camel-zy.github.io/Camel_Blog/tags/hexo/"},{"name":"fluid","slug":"fluid","permalink":"https://camel-zy.github.io/Camel_Blog/tags/fluid/"},{"name":"blog","slug":"blog","permalink":"https://camel-zy.github.io/Camel_Blog/tags/blog/"},{"name":"C","slug":"C","permalink":"https://camel-zy.github.io/Camel_Blog/tags/C/"}]}