<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Gitee自动部署</title>
    <link href="/Camel_Blog/2022/07/16/Gitee%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/"/>
    <url>/Camel_Blog/2022/07/16/Gitee%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/</url>
    
    <content type="html"><![CDATA[<p>众所周知 Gitee自动部署功能是Gitee Pages Pro的功能。</p><span id="more"></span><p>所以就有了<a href="https://github.com/marketplace/actions/gitee-pages-action#gitee-pages-action">Gitee Pages Action</a>这个项目。</p><p>按照说明一步步配就行，配置示例已经写的非常清晰。</p><p>遇到问题再来记录吧。</p><p>(所以我这只是水一篇博客而已</p>]]></content>
    
    
    
    <tags>
      
      <tag>gitee</tag>
      
      <tag>github</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo配置</title>
    <link href="/Camel_Blog/2022/07/16/hexo%E9%85%8D%E7%BD%AE/"/>
    <url>/Camel_Blog/2022/07/16/hexo%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<p>记录以下hexo相关的基础配置。</p><span id="more"></span><p>_config.yml文件配置详细内容可以看<a href="https://hexo.io/docs/configuration">官网</a></p><p>以下仅简单记录下我遇到的问题</p><h1 id="生成时包含其他文件"><a href="#生成时包含其他文件" class="headerlink" title="生成时包含其他文件"></a>生成时包含其他文件</h1><p>希望hexo在生成时将readme.md workflows之类的文件加上一起部署到仓库，所以就有了这个需求。</p><p>首先在_config.yml文件的<code>include: </code>中加上所需要包含的文件(根目录为source/)，此处支持<a href="https://github.com/micromatch/micromatch#extended-globbing">通配符</a></p><p>例如：</p><figure class="highlight avrasm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs avrasm"><span class="hljs-symbol">include:</span> <br>  - <span class="hljs-string">&quot;.github/workflows/*&quot;</span><br></code></pre></div></td></tr></table></figure><p>然后如果不希望文件在生成时被自动转换的话，可以在<code>skip_render: </code>中加上路径，此处支持<a href="https://github.com/micromatch/micromatch#extended-globbing">通配符</a></p><p>此处添加的文件将会被直接复制到生成后的文件夹(public)中。例如：</p><figure class="highlight avrasm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs avrasm"><span class="hljs-symbol">skip_render:</span> <br>  - <span class="hljs-string">&quot;.github/workflows/*&quot;</span><br></code></pre></div></td></tr></table></figure><p>然鹅在配完上述内容后，<code>hexo generate</code>生成的<code>public</code>文件夹中确实有了文件，但是使用<code>hexo deploy</code>时我放的<code>.github</code>文件夹又消失了。</p><p>所以后来又去看了下<code>hexo-deploy-git</code>的<a href="https://github.com/hexojs/hexo-deployer-git">配置说明</a></p><p>如果需要上传隐藏文件的话 需要在<code>_config.yml</code>中的<code>deploy</code>部分添加<code>ignore_hidden: false</code>配置</p><p>然后就搞定了</p>]]></content>
    
    
    
    <tags>
      
      <tag>blog</tag>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu源文件备份</title>
    <link href="/Camel_Blog/2022/07/16/Ubuntu%E6%BA%90%E6%96%87%E4%BB%B6%E5%A4%87%E4%BB%BD/"/>
    <url>/Camel_Blog/2022/07/16/Ubuntu%E6%BA%90%E6%96%87%E4%BB%B6%E5%A4%87%E4%BB%BD/</url>
    
    <content type="html"><![CDATA[<p>之前源文件被我改得乱七八糟，现在重新恢复为官方源文件，顺便做个备份。</p><span id="more"></span><p>官方源文件备份</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk"><span class="hljs-comment">#deb cdrom:[Ubuntu 20.04 LTS _Focal Fossa_ - Release amd64 (20200423)]/ focal main restricted</span><br><br><span class="hljs-comment"># See http://help.ubuntu.com/community/UpgradeNotes for how to upgrade to</span><br><span class="hljs-comment"># newer versions of the distribution.</span><br>deb http:<span class="hljs-regexp">//</span>cn.archive.ubuntu.com<span class="hljs-regexp">/ubuntu/</span> focal main restricted<br><span class="hljs-comment"># deb-src http://cn.archive.ubuntu.com/ubuntu/ focal main restricted</span><br><br><span class="hljs-comment">## Major bug fix updates produced after the final release of the</span><br><span class="hljs-comment">## distribution.</span><br>deb http:<span class="hljs-regexp">//</span>cn.archive.ubuntu.com<span class="hljs-regexp">/ubuntu/</span> focal-updates main restricted<br><span class="hljs-comment"># deb-src http://cn.archive.ubuntu.com/ubuntu/ focal-updates main restricted</span><br><br><span class="hljs-comment">## N.B. software from this repository is ENTIRELY UNSUPPORTED by the Ubuntu</span><br><span class="hljs-comment">## team. Also, please note that software in universe WILL NOT receive any</span><br><span class="hljs-comment">## review or updates from the Ubuntu security team.</span><br>deb http:<span class="hljs-regexp">//</span>cn.archive.ubuntu.com<span class="hljs-regexp">/ubuntu/</span> focal universe<br><span class="hljs-comment"># deb-src http://cn.archive.ubuntu.com/ubuntu/ focal universe</span><br>deb http:<span class="hljs-regexp">//</span>cn.archive.ubuntu.com<span class="hljs-regexp">/ubuntu/</span> focal-updates universe<br><span class="hljs-comment"># deb-src http://cn.archive.ubuntu.com/ubuntu/ focal-updates universe</span><br><br><span class="hljs-comment">## N.B. software from this repository is ENTIRELY UNSUPPORTED by the Ubuntu </span><br><span class="hljs-comment">## team, and may not be under a free licence. Please satisfy yourself as to </span><br><span class="hljs-comment">## your rights to use the software. Also, please note that software in </span><br><span class="hljs-comment">## multiverse WILL NOT receive any review or updates from the Ubuntu</span><br><span class="hljs-comment">## security team.</span><br>deb http:<span class="hljs-regexp">//</span>cn.archive.ubuntu.com<span class="hljs-regexp">/ubuntu/</span> focal multiverse<br><span class="hljs-comment"># deb-src http://cn.archive.ubuntu.com/ubuntu/ focal multiverse</span><br>deb http:<span class="hljs-regexp">//</span>cn.archive.ubuntu.com<span class="hljs-regexp">/ubuntu/</span> focal-updates multiverse<br><span class="hljs-comment"># deb-src http://cn.archive.ubuntu.com/ubuntu/ focal-updates multiverse</span><br><br><span class="hljs-comment">## N.B. software from this repository may not have been tested as</span><br><span class="hljs-comment">## extensively as that contained in the main release, although it includes</span><br><span class="hljs-comment">## newer versions of some applications which may provide useful features.</span><br><span class="hljs-comment">## Also, please note that software in backports WILL NOT receive any review</span><br><span class="hljs-comment">## or updates from the Ubuntu security team.</span><br>deb http:<span class="hljs-regexp">//</span>cn.archive.ubuntu.com<span class="hljs-regexp">/ubuntu/</span> focal-backports main restricted universe multiverse<br><span class="hljs-comment"># deb-src http://cn.archive.ubuntu.com/ubuntu/ focal-backports main restricted universe multiverse</span><br><br><span class="hljs-comment">## Uncomment the following two lines to add software from Canonical&#x27;s</span><br><span class="hljs-comment">## &#x27;partner&#x27; repository.</span><br><span class="hljs-comment">## This software is not part of Ubuntu, but is offered by Canonical and the</span><br><span class="hljs-comment">## respective vendors as a service to Ubuntu users.</span><br><span class="hljs-comment"># deb http://archive.canonical.com/ubuntu focal partner</span><br><span class="hljs-comment"># deb-src http://archive.canonical.com/ubuntu focal partner</span><br><br>deb http:<span class="hljs-regexp">//</span>security.ubuntu.com/ubuntu focal-security main restricted<br><span class="hljs-comment"># deb-src http://security.ubuntu.com/ubuntu focal-security main restricted</span><br>deb http:<span class="hljs-regexp">//</span>security.ubuntu.com/ubuntu focal-security universe<br><span class="hljs-comment"># deb-src http://security.ubuntu.com/ubuntu focal-security universe</span><br>deb http:<span class="hljs-regexp">//</span>security.ubuntu.com/ubuntu focal-security multiverse<br><span class="hljs-comment"># deb-src http://security.ubuntu.com/ubuntu focal-security multiverse</span><br><br><span class="hljs-comment"># This system was installed using small removable media</span><br><span class="hljs-comment"># (e.g. netinst, live or single CD). The matching &quot;deb cdrom&quot;</span><br><span class="hljs-comment"># entries were disabled at the end of the installation process.</span><br><span class="hljs-comment"># For information about how to configure apt package sources,</span><br><span class="hljs-comment"># see the sources.list(5) manual.</span><br></code></pre></div></td></tr></table></figure><p><a href="https://developer.aliyun.com/mirror/ubuntu?spm=a2c6h.13651102.0.0.3e221b11MBcu4I">Ubuntu阿里云镜像</a></p><p>只需将文件中<code>archive.ubuntu.com</code>替换为<code>mirrors.aliyun.com</code>即可。</p><p>ps:使用<code>code sources.list</code>可在vscode中打开文件。</p><p>替换为ZJU镜像同理。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Ubuntu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu控制笔记本性能释放</title>
    <link href="/Camel_Blog/2022/06/18/Ubuntu%E6%8E%A7%E5%88%B6%E7%AC%94%E8%AE%B0%E6%9C%AC%E6%80%A7%E8%83%BD%E9%87%8A%E6%94%BE/"/>
    <url>/Camel_Blog/2022/06/18/Ubuntu%E6%8E%A7%E5%88%B6%E7%AC%94%E8%AE%B0%E6%9C%AC%E6%80%A7%E8%83%BD%E9%87%8A%E6%94%BE/</url>
    
    <content type="html"><![CDATA[<p>在使用Ubuntu时发现性能无法得到完全释放，风扇转速也十分有限。</p><span id="more"></span><p>型号：华硕 天选2</p><h1 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h1><p>在Win10中，电脑可使用Fn+F5切换性能释放模式（静音、平衡、增强），因此有了在Ubuntu下调整模式的想法。</p><h1 id="二、一些尝试"><a href="#二、一些尝试" class="headerlink" title="二、一些尝试"></a>二、一些尝试</h1><p>参照网络某些博客使用lm-sensors后，发现找不到可调节的风扇，并没有达到预期效果。</p><h1 id="三、解决方式"><a href="#三、解决方式" class="headerlink" title="三、解决方式"></a>三、解决方式</h1><p>这种方式应该仅限于华硕笔记本。</p><blockquote><p>In Kernel 5.6 there is a fan mode for asus laptops, check if you have /sys/devices/platform/asus-nb-wmi/throttle_thermal_policy 2 - Silent, 0 - Balance, 1 - Turbo, similar to the modes in armoury crate on windows.</p></blockquote><p>在/sys/devices/platform/asus-nb-wmi/throttle_thermal_policy内存储的数字即为当前模式：</p><p>其中默认的0代表平衡模式，1代表增强模式，2代表静音模式。</p><p>所以解决方法就很简单啦 修改该文件的值即可。</p><p>在这边也简单记录下命令。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">su  <span class="hljs-comment"># 需要权限</span><br><span class="hljs-built_in">echo</span> 1 &gt; /sys/devices/platform/asus-nb-wmi/throttle_thermal_policy <span class="hljs-comment"># 切换为增强模式</span><br><span class="hljs-built_in">echo</span> 0 &gt; /sys/devices/platform/asus-nb-wmi/throttle_thermal_policy <span class="hljs-comment"># 切换为平衡模式</span><br><span class="hljs-built_in">echo</span> 2 &gt; /sys/devices/platform/asus-nb-wmi/throttle_thermal_policy <span class="hljs-comment"># 切换为静音模式</span><br></code></pre></div></td></tr></table></figure><p>嫌命令麻烦的话也可以看看这个<a href="https://github.com/leonmaxx/asus_fanmode">仓库</a>，不过我没试过。</p><h1 id="四、参考资料"><a href="#四、参考资料" class="headerlink" title="四、参考资料"></a>四、参考资料</h1><p><a href="https://askubuntu.com/questions/1254364/how-to-control-fans-on-an-asus-laptop?newreg=90b0e4d9f8ce481fa9370b5544606c8d">How to control fans on an asus laptop</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>ubuntu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>sqlmap使用笔记</title>
    <link href="/Camel_Blog/2022/05/12/sqlmap%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/"/>
    <url>/Camel_Blog/2022/05/12/sqlmap%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>记录一下sqlmap的（非常基础的）知识啥的</p><span id="more"></span><p><del>sqlmap从入门到入狱</del></p><h1 id="一、sqlmap简介"><a href="#一、sqlmap简介" class="headerlink" title="一、sqlmap简介"></a>一、sqlmap简介</h1><blockquote><p>SQLMap 是一个开源的渗透测试工具，可以用来进行自动化检测，利用 SQL  注入漏洞，获取数据库服务器的权限。它具有功能强大的检测引擎，针对各种不同类型数据库的渗透测试的功能选项，包括获取数据库中存储的数据，访问操作系统文件甚至可以通过外带数据连接的方式执行操作系统命令。</p></blockquote><p>sqlmap支持的五种不同的注入方式：</p><blockquote><p>Boolean-based blind：sqlmap 替换或附加到 HTTP 请求中的受影响参数，包含 SELECT 子语句的语法有效的 SQL 语句字符串，或用户要检索其输出的任何其他 SQL 语句。对于每个 HTTP 响应，通过在 HTTP 响应标头 / 正文与原始请求之间进行比较，该工具可以逐字符推断注入的语句的输出。或者，用户可以提供字符串或正则表达式以匹配 True 页面。在 sqlmap 中实现的用于执行此技术的二等分算法能够获取最多七个 HTTP 请求的输出每个字符。如果输出不在明文纯字符集内，则 sqlmap 将采用更大范围的算法来检测输出。</p><p>Time-based blind：sqlmap 替换或附加到 HTTP 请求中的受影响参数，该语法有效的 SQL 语句字符串包含查询，该查询将使后端 DBMS 保留一定的秒数。对于每个 HTTP 响应，通过在 HTTP 响应时间和原始请求之间进行比较，该工具可以逐字符推断注入的语句的输出。像基于布尔的技术一样，应用二等分算法。</p><p>Error-based：sqlmap 替换或附加到受影响的参数特定于数据库的错误消息引发语句，并解析 HTTP 响应标头和正文，以查找包含已注入的预定义字符链和其中的子查询语句输出的 DBMS 错误消息。仅当 Web 应用程序已配置为公开后端数据库管理系统错误消息时，此技术才有效。</p><p>UNION query-based：sqlmap 将一个语法有效的 SQL 语句附加到受影响的参数，该语句以开头 UNION ALL SELECT。当 Web 应用程序页面 SELECT 在 for 循环或类似情况下直接传递语句的输出时，此技术有效，以便查询输出的每一行都打印在页面内容上。sqlmap 还能够利用部分（单项）UNION 查询 SQL 注入漏洞，该漏洞在语句的输出未在 for 构造中循环而仅显示查询输出的第一项时发生。联合查询分为内联（inner join）、左联（left outer join）、右联（right outer join）和全联（full outer join）</p><p>Stacked queries：sqlmap 测试 Web 应用程序是否支持堆叠查询，然后在支持的情况下将 HTTP 请求后的分号（;）附加到受影响的参数上，后跟 SQL 语句以被执行。此技术对于运行除 SELECT（例如）数据定义或数据操作语句以外的 SQL 语句很有用，这可能导致文件系统的读写访问和操作系统命令的执行，具体取决于底层的后端数据库管理系统和会话用户特权。</p></blockquote><p>软件可直接通过<a href="https://sqlmap.org/">官网</a>下载安装</p><p><a href="https://github.com/sqlmapproject/sqlmap">github项目地址</a></p><h1 id="二、使用方式"><a href="#二、使用方式" class="headerlink" title="二、使用方式"></a>二、使用方式</h1><h2 id="指定目标"><a href="#指定目标" class="headerlink" title="指定目标"></a>指定目标</h2><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> python3 sqlmap.py -u <span class="hljs-string">&quot;url&quot;</span><span class="hljs-comment">#指定目标网址 url的最后应当有参数 例如questionid=0</span></span><br></code></pre></div></td></tr></table></figure><p>可能会问是否需要提高测试等级 比较推荐使用 3 等级进行测试。</p><p>也可以使用 –level 指定测试等级</p><h2 id="列出库"><a href="#列出库" class="headerlink" title="列出库"></a>列出库</h2><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> python3 sqlmap.py -u <span class="hljs-string">&quot;url&quot;</span> --dbs</span><br></code></pre></div></td></tr></table></figure><h2 id="列出表"><a href="#列出表" class="headerlink" title="列出表"></a>列出表</h2><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> python3 sqlmap.py -u <span class="hljs-string">&quot;url&quot;</span> -D 库名 --tables</span><br></code></pre></div></td></tr></table></figure><h1 id="列出字段"><a href="#列出字段" class="headerlink" title="列出字段"></a>列出字段</h1><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> python3 sqlmap.py -u <span class="hljs-string">&quot;url&quot;</span> -D 库名 -T 表名 --columns</span><br></code></pre></div></td></tr></table></figure><p>后面有空再写 咕咕咕</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://gitbook.cn/books/5ba8393639ea516190a9b8f8/index.html">SQLMap 从入门到入狱详细指南</a></p><p><a href="https://www.wangan.com/docs/1060">SqlMap中文版使用教程</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>note</tag>
      
      <tag>sqlmap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从零开始使用浙江大学自动健康打卡</title>
    <link href="/Camel_Blog/2022/05/10/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E8%87%AA%E5%8A%A8%E5%81%A5%E5%BA%B7%E6%89%93%E5%8D%A1/"/>
    <url>/Camel_Blog/2022/05/10/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E8%87%AA%E5%8A%A8%E5%81%A5%E5%BA%B7%E6%89%93%E5%8D%A1/</url>
    
    <content type="html"><![CDATA[<p>由于目前一天不打卡就会被取消蓝码，所以大家对自动打卡的需求也就越来越高。</p><span id="more"></span><p>为节约每天重复的打卡时间，也尽可能避免忘记打卡造成的麻烦，自动打卡应运而生。</p><p>为了降低自动打卡的使用门槛，所以就有了这份胎教级教程，从零开始实现自动健康打卡。</p><p>顺带一提，目前github上的自动打卡在众多开发者的努力下功能已较为完善，稳定性也比最初提升了不少。</p><h1 id="〇、特别声明"><a href="#〇、特别声明" class="headerlink" title="〇、特别声明"></a>〇、特别声明</h1><p><strong>本文禁止任何形式的转载。</strong></p><p>本文仅用于学习交流使用，请严格遵守校纪校规，如实上报健康状态。对一切非法使用所产生的后果概不负责。</p><p>若本文侵犯到您的利益请联系我删除。</p><h1 id="一、注册github"><a href="#一、注册github" class="headerlink" title="一、注册github"></a>一、注册github</h1><blockquote><p>神说：要有github。</p></blockquote><p>作为世界上最大的<del>同性交友网站</del>代码托管平台，github上超2亿代码库。我目前是用的自动打卡也是来自于此。</p><p>打开<a href="https://github.com/">github</a>，点击右上角的Sign Up 根据提示完成注册即可。（国内访问github可能不稳定，若无法访问可以过一段时间再试。如果有魔法的话访问速度会快一点<img src="signup.png"></p><h1 id="二、-Fork自动健康打卡仓库"><a href="#二、-Fork自动健康打卡仓库" class="headerlink" title="二、 Fork自动健康打卡仓库"></a>二、 Fork自动健康打卡仓库</h1><p>完成注册并登录后，打开<a href="https://github.com/GCS-ZHN/AutoCard">自动健康打卡仓库</a>，我目前使用的就是这个AutoCard仓库。</p><p>然后点击右上角的Fork，也就是将代码复制到自己的仓库。然后点击create fork</p><p><img src="fork.png"></p><p><img src="createfork.png"></p><p>页面跳转后，若红框处左上角为你的用户名，且下面有一行fork from什么的小字，则说明fork已完成。</p><p><img src="afterfork.png"></p><h1 id="三、钉钉推送"><a href="#三、钉钉推送" class="headerlink" title="三、钉钉推送"></a>三、钉钉推送</h1><p>因为自动打卡可能会失败，需要你每天关注一下有没有打卡成功，所以需要开个钉钉推送功能。</p><p>首先随便新建个群，用于消息推送。</p><p>然后在<strong>电脑端</strong>（你前面不会一直是在手机上操作的吧）打开钉钉的那个群，点右上角群设置-&gt;智能群助手-&gt;添加机器人-&gt;设置</p><p><img src="dinggroup.png"></p><p><img src="dingaddbot.png"></p><p>点击自定义-&gt;添加</p><p><img src="customedbot.png"></p><p>机器人名字可随便写，但注意<strong>勾选加签</strong>，并点击下面的复制按钮复制生成的密钥，找个地方记录下，等会要用</p><p><img src="createbot.png"></p><p>点击完成后，点击复制按钮复制生成的Webhook，找个地方记录下，等会要用</p><p><img src="finishbot.png"></p><h1 id="四、仓库设置"><a href="#四、仓库设置" class="headerlink" title="四、仓库设置"></a>四、仓库设置</h1><h2 id="添加Secrets"><a href="#添加Secrets" class="headerlink" title="添加Secrets"></a>添加Secrets</h2><p>回到刚才你的仓库，点击Settings-&gt;Secrets&gt;Actions</p><p><img src="settings.png"></p><p>点击New repository secret</p><p><img src="newsecret.png"></p><p>Name中填写<strong>AUTOCARD_USER</strong> Value中填写你的浙大通行证账号 然后点击Add secret</p><p><img src="addsecret.png"></p><p>重复上述两步操作继续添加secret 其中Name和Value参照以下表格</p><p>那个<strong>AUTOCARD_CACHE_FLAG</strong>的Value填<code>1</code>即可</p><table><thead><tr><th>Name</th><th>Value</th><th>备注</th></tr></thead><tbody><tr><td><strong>AUTOCARD_USER</strong></td><td>浙大通行证账号</td><td></td></tr><tr><td><strong>AUTOCARD_PWD</strong></td><td>浙大通行证密码</td><td></td></tr><tr><td><strong>AUTOCARD_DINGTALK_URL</strong></td><td>第三步中记录的Webhook</td><td></td></tr><tr><td><strong>AUTOCARD_DINGTALK_SECRET</strong></td><td>第三步中记录的密钥</td><td></td></tr><tr><td><strong>AUTOCARD_CACHE_FLAG</strong></td><td><code>1</code></td><td>用于程序缓存输出提供一个索引，任意值即可</td></tr><tr><td><strong>AUTOCARD_MAX_TRIAL</strong></td><td><code>5</code></td><td>打卡失败后重试次数</td></tr><tr><td><strong>AUTOCARD_DELAY</strong></td><td><code>0</code></td><td>是否随机延迟打卡</td></tr></tbody></table><h2 id="可选项：打卡时间修改"><a href="#可选项：打卡时间修改" class="headerlink" title="可选项：打卡时间修改"></a>可选项：打卡时间修改</h2><p>回到code页面，点击红框中的workflow</p><p><img src="githubcode.png"></p><p>点击schedule.yml</p><p><img src="schedule.png"></p><p>点击右侧的笔</p><p><img src="ymlpen.png"></p><p>修改此处的cron即可修改每日打卡的时间，例如我将这个改为了<code>- cron: &#39;20 16,0  * * *&#39;</code>，即协调世界时的每天16:20和00:20尝试打卡一次。（每天打两次是双保险，自动打卡有可能会失败） 具体cron语法可以自行查询</p><p>修改完后点击Start commit -&gt; Commit changes 即可</p><p>修改完后点击Start commit -&gt; Commit changes 即可</p><p><img src="commit.png"></p><h2 id="启动Actions"><a href="#启动Actions" class="headerlink" title="启动Actions"></a>启动Actions</h2><p>点击上方Actions，并点击绿框启用Actions</p><p><img src="actions.png"></p><p>点击左边的schedule 再点击右边的enable workflow</p><p><img src="enableworkflow.png"></p><p>此时已完成设置。</p><h2 id="测试一下下"><a href="#测试一下下" class="headerlink" title="测试一下下"></a>测试一下下</h2><p>看到仓库右上角的小星星没</p><p><img src="star.png"></p><p>下面要跟着做呦</p><p>点一下这个小星星，它会变亮。</p><p>再点一下，它就灭了。</p><p><del>这真的不是单纯为了逗你玩 其实是为了让Action跑一遍</del></p><p>这边这个黄圈就意味着已经在运行啦</p><p><img src="running.png"></p><p>稍等一会，这个东西可能有点慢。</p><p>过一段时间看看钉钉刚才那个群里有没有收到消息推送。</p><p>okk如果一切顺利的话应该就已经完成设置啦，记得每天看一下有没有打卡成功就行啦。</p><h1 id="五、部分问题处理"><a href="#五、部分问题处理" class="headerlink" title="五、部分问题处理"></a>五、部分问题处理</h1><p>如果不熟悉上述的这些东西的话，自动打卡出问题时可能处理起来也会比较困难。</p><p>那遇到问题怎么办呢？</p><p><del>自己看着办咯</del></p><p>可以康康下面的常见问题。</p><h2 id="代码库需要更新"><a href="#代码库需要更新" class="headerlink" title="代码库需要更新"></a>代码库需要更新</h2><p>这个自动健康打卡的库有大佬在维护，时不时可能会需要更新。</p><p>辣么如何更新呢？</p><p>进入你的仓库Code页面 点击Fetch upstream。如果显示如下图的话就需要更新。</p><p><img src="merge.png"></p><p>点击Fetch and merge 大概还需要再点个绿框 这样就可以啦。</p><p>无需更新的话是如下图所示。</p><p><img src="updated.png"></p><h2 id="打卡失败-如何重新启动脚本？"><a href="#打卡失败-如何重新启动脚本？" class="headerlink" title="打卡失败 如何重新启动脚本？"></a>打卡失败 如何重新启动脚本？</h2><p>一般来讲提示信息获取失败或者压根没推送信息那就说明自动打卡失败了。</p><p>进入你的仓库Actions界面 点击红框中的schedule</p><p><img src="fail.png"></p><p>再点击Re-run all jobs -&gt; Re-run jobs</p><p><img src="rerun.png"></p><p>即可重新运行一次。</p>]]></content>
    
    
    
    <tags>
      
      <tag>github</tag>
      
      <tag>script</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在双系统中共享蓝牙</title>
    <link href="/Camel_Blog/2022/04/25/%E5%9C%A8%E5%8F%8C%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%85%B1%E4%BA%AB%E8%93%9D%E7%89%99%E9%BC%A0%E6%A0%87/"/>
    <url>/Camel_Blog/2022/04/25/%E5%9C%A8%E5%8F%8C%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%85%B1%E4%BA%AB%E8%93%9D%E7%89%99%E9%BC%A0%E6%A0%87/</url>
    
    <content type="html"><![CDATA[<p>双系统在切换系统后，蓝牙鼠标需要重新配对连接。</p><p>以下方法可解决这一问题</p><span id="more"></span><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>首先简单解释下蓝牙在双系统中需要重新配对的原因：</p><p>蓝牙配对是根据设备的MAC地址和随机生成的密钥连接，同一设备的MAC地址相同但在双系统中随机生成的密钥不同，因此每次切换系统连接都需重新配对。</p><p>本文所提的方法原理为更改Linux下的密钥使之与Windows下的密钥相同。</p><h1 id="在Linux中配对蓝牙设备"><a href="#在Linux中配对蓝牙设备" class="headerlink" title="在Linux中配对蓝牙设备"></a>在Linux中配对蓝牙设备</h1><p>在Linux中配对蓝牙，从而在Linux中生成配置文件。</p><h1 id="在Windows中配对蓝牙设备"><a href="#在Windows中配对蓝牙设备" class="headerlink" title="在Windows中配对蓝牙设备"></a>在Windows中配对蓝牙设备</h1><p>在Windows中配对蓝牙，从而在Windows中生成配置文件。</p><h1 id="读取Windows下配置文件"><a href="#读取Windows下配置文件" class="headerlink" title="读取Windows下配置文件"></a>读取Windows下配置文件</h1><p>以下为方便起见采用在Linux下使用dumphive软件读取Windows下配置文件的方法</p><h2 id="获取dumphive"><a href="#获取dumphive" class="headerlink" title="获取dumphive"></a>获取dumphive</h2><p>该软件目前已停止更新，源码可以在此<a href="https://gitorious.org/canaima-gnu-linux/dumphive">此镜像站</a>获取，或使用本站提供的<a href="canaima-gnu-linuxdumphive-90045ba.tar.gz">备份文件</a></p><h2 id="编译dumphive"><a href="#编译dumphive" class="headerlink" title="编译dumphive"></a>编译dumphive</h2><p>该软件使用Free Pascal编写（这都是些什么古董），故需要Free Pascal编译器。</p><figure class="highlight cmake"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cmake">sudo apt <span class="hljs-keyword">install</span> fpc<br></code></pre></div></td></tr></table></figure><p>然后进入到源码的src目录下</p><figure class="highlight ebnf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">make</span><br></code></pre></div></td></tr></table></figure><p>即可完成编译，得到dumphive文件。</p><h2 id="读取注册表"><a href="#读取注册表" class="headerlink" title="读取注册表"></a>读取注册表</h2><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">sudo mount <span class="hljs-regexp">/dev/</span>nvme0n1p3 /mnt          <span class="hljs-comment"># nvme0n1p3 是 Windows 系统盘</span><br>cd <span class="hljs-regexp">/mnt/</span>Windows<span class="hljs-regexp">/System32/</span>config  <br>~<span class="hljs-regexp">/dumphive SYSTEM ~/</span>system.reg  <span class="hljs-comment"># 此处将dumphive至于~目录下</span><br><br>grep -Pn <span class="hljs-string">&#x27;BTHPORT.*(\\[\da-f]&#123;12&#125;)&#123;2&#125;&#x27;</span> ~/system.reg     <span class="hljs-comment">#获取蓝牙配对相关信息</span><br><br><span class="hljs-number">171486</span>:[ROOT\ControlSet001\Services\BTHPORT\Parameters\Keys\ec2exxxxxxxx\ed5fxxxxxx95]<br><br><span class="hljs-comment"># 返回值最前面的数字即为此信息所在的行号</span><br><br>vim ~/system.reg +<span class="hljs-number">171486</span>    <span class="hljs-comment"># 打开文件，并将光标移动到171486行，即可看到蓝牙配对相关信息</span><br></code></pre></div></td></tr></table></figure><h2 id="修改蓝牙配对信息"><a href="#修改蓝牙配对信息" class="headerlink" title="修改蓝牙配对信息"></a>修改蓝牙配对信息</h2><figure class="highlight elixir"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs elixir">sudo su<br>cd /var/lib/bluetooth/EC\<span class="hljs-symbol">:</span><span class="hljs-number">2</span>E\<span class="hljs-symbol">:XX</span>\<span class="hljs-symbol">:XX</span>\<span class="hljs-symbol">:XX</span>\<span class="hljs-symbol">:XX/</span>   <span class="hljs-comment"># 进入此电脑的蓝牙目录（文件名为电脑MAC地址）</span><br>cd ED\<span class="hljs-symbol">:</span><span class="hljs-number">5</span>F\<span class="hljs-symbol">:XX</span>\<span class="hljs-symbol">:XX</span>\<span class="hljs-symbol">:XX</span>\<span class="hljs-symbol">:</span><span class="hljs-number">94</span>/  <span class="hljs-comment"># 进入配对设备的目录（文件名为配对设备MAC地址）</span><br><span class="hljs-comment"># 注：此时发现文件名与上面注册表中不同（末位可能不同） 需要更改文件名</span><br><span class="hljs-comment"># 更改后</span><br>cd ED\<span class="hljs-symbol">:</span><span class="hljs-number">5</span>F\<span class="hljs-symbol">:XX</span>\<span class="hljs-symbol">:XX</span>\<span class="hljs-symbol">:XX</span>\<span class="hljs-symbol">:</span><span class="hljs-number">95</span>/<br></code></pre></div></td></tr></table></figure><p>接下来根据注册表中内容和以下对应表格修改参数</p><table><thead><tr><th>Windows</th><th>Linux</th><th>参数格式修改</th></tr></thead><tbody><tr><td>LTK</td><td>[LongTermKey] Key</td><td>去逗号改大写</td></tr><tr><td>IRK</td><td>[IdentityResolvingKey] Key</td><td>去逗号改大写</td></tr><tr><td>EDIV</td><td>[LongTermKey] EDiv</td><td>十六进制转十进制</td></tr><tr><td>ERand</td><td>[LongTermKey] Rand</td><td>倒序十六进制转十进制</td></tr></tbody></table><p>特别注意：ERand需先倒序再转换进制</p><p>例如：</p><figure class="highlight autoit"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs autoit"><span class="hljs-string">&quot;ERand&quot;</span>=<span class="hljs-built_in">hex</span>(b):<span class="hljs-number">55</span>,<span class="hljs-number">8</span>c,<span class="hljs-number">80</span>,<span class="hljs-number">38</span>,<span class="hljs-number">10</span>,<span class="hljs-number">7</span>f,e1,b7<br></code></pre></div></td></tr></table></figure><p>应先倒序相连变为<code>b7e17f1038808c55</code></p><p>再转十进制变为<code>13250011286344862805</code></p><h1 id="重启蓝牙"><a href="#重启蓝牙" class="headerlink" title="重启蓝牙"></a>重启蓝牙</h1><figure class="highlight maxima"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs maxima">sudo systemctl <span class="hljs-built_in">restart</span> bluetooth.service<br></code></pre></div></td></tr></table></figure><p>此时即可自动完成蓝牙设备的配对连接。</p><p>贴一个<a href="https://blog.nanpuyue.com/2018/040.html">参考博客</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>ubuntu</tag>
      
      <tag>windows</tag>
      
      <tag>bluetooth</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CMake的使用基础</title>
    <link href="/Camel_Blog/2022/04/23/CMake%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80/"/>
    <url>/Camel_Blog/2022/04/23/CMake%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p>做C大程的时候研究了一下cmake的用法<br>下面是CMakeLists.txt的基础写法</p><span id="more"></span><p>以C大程所需的多文件结构为例</p><p>主目录下的CMakeLists.txt：</p><figure class="highlight cmake"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cmake"><span class="hljs-comment"># 最低版本号要求</span><br><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.0</span>.<span class="hljs-number">0</span>)<br><span class="hljs-comment"># 项目名称</span><br><span class="hljs-keyword">project</span>(Text_Editer VERSION <span class="hljs-number">0.1</span>.<span class="hljs-number">0</span>)<br><br><span class="hljs-keyword">include</span>(CTest)<br><span class="hljs-keyword">enable_testing</span>()<br><br><span class="hljs-comment"># 包含目录</span><br><span class="hljs-keyword">include_directories</span>(<br>    <span class="hljs-variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/<span class="hljs-keyword">include</span>/libgraphics<br>    <span class="hljs-variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/<span class="hljs-keyword">include</span>/simpleGUI<br>)<br><span class="hljs-keyword">aux_source_directory</span>(. SRC_LIST)<br><span class="hljs-comment"># 添加子目录</span><br><span class="hljs-keyword">add_subdirectory</span>(<span class="hljs-keyword">include</span>/libgraphics)<br><span class="hljs-keyword">add_subdirectory</span>(<span class="hljs-keyword">include</span>/simpleGUI)<br><span class="hljs-comment"># 生成可执行文件</span><br><span class="hljs-keyword">add_executable</span>(Text_Editer <span class="hljs-variable">$&#123;SRC_LIST&#125;</span>)<br><span class="hljs-comment"># 链接</span><br><span class="hljs-keyword">target_link_libraries</span>(Text_Editer<br>    libgraphics<br>    simpleGUI<br>    FileProcess<br>    GUI<br>    TextBox<br>)<br><br><span class="hljs-keyword">set</span>(CPACK_PROJECT_NAME <span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span>)<br><span class="hljs-keyword">set</span>(CPACK_PROJECT_VERSION <span class="hljs-variable">$&#123;PROJECT_VERSION&#125;</span>)<br><span class="hljs-keyword">include</span>(CPack)<br><br></code></pre></div></td></tr></table></figure><p>子目录下的CMakeLists.txt：</p><figure class="highlight cmake"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cmake"><span class="hljs-keyword">include_directories</span>(<br>    <span class="hljs-variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/<span class="hljs-keyword">include</span>/libgraphics<br>    <span class="hljs-variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/<span class="hljs-keyword">include</span>/simpleGUI<br>)   <span class="hljs-comment"># 注意如果子目录下的代码也需要include其他库的话 这里也需要include_directories</span><br><span class="hljs-keyword">aux_source_directory</span>(. DIR_LIB_SRCS)<br><span class="hljs-keyword">add_library</span>(libgraphics <span class="hljs-variable">$&#123;DIR_LIB_SRCS&#125;</span>)<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>cmake</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C大程随性笔记</title>
    <link href="/Camel_Blog/2022/02/22/C%E5%A4%A7%E7%A8%8B%E9%9A%8F%E6%80%A7%E7%AC%94%E8%AE%B0/"/>
    <url>/Camel_Blog/2022/02/22/C%E5%A4%A7%E7%A8%8B%E9%9A%8F%E6%80%A7%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>一份C大程的随意笔记</p><span id="more"></span><p>要是有哪里写错了那就写错了吧 反正考完理论考我也不用记这些东西了(</p><h1 id="enum"><a href="#enum" class="headerlink" title="enum"></a>enum</h1><p>关于枚举类型：</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">TypeName</span>&#123;</span>ValueName1,ValueName2,...&#125;;<br></code></pre></div></td></tr></table></figure><p>例如：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">week</span>&#123;</span> Mon = <span class="hljs-number">1</span>, Tues = <span class="hljs-number">2</span>, Wed = <span class="hljs-number">3</span>, Thurs = <span class="hljs-number">4</span>, Fri = <span class="hljs-number">5</span>, Sat = <span class="hljs-number">6</span>, Sun = <span class="hljs-number">7</span> &#125; day;  <span class="hljs-comment">//内部用逗号分隔 最后为空 不是分号</span><br>day = Mon;<br></code></pre></div></td></tr></table></figure><p>对于没有赋值的元素，其值为<strong>前一元素加1</strong> 初值为0</p><p>例如</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Test</span> &#123;</span>x, y = <span class="hljs-number">4</span>, z&#125;;<br>x == <span class="hljs-number">0</span><br>z == <span class="hljs-number">5</span>    <br></code></pre></div></td></tr></table></figure><h1 id="typedef"><a href="#typedef" class="headerlink" title="typedef"></a>typedef</h1><p>这边关于typedef再多记一点：对于数组的typedef</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> <span class="hljs-built_in">vector</span>[<span class="hljs-number">10</span>];<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> matrix[<span class="hljs-number">5</span>][<span class="hljs-number">5</span>];<br></code></pre></div></td></tr></table></figure><p>一个挺好的理解办法：去掉typedef就是变量定义。</p><h1 id="联合（共同）体"><a href="#联合（共同）体" class="headerlink" title="联合（共同）体"></a>联合（共同）体</h1><p>结构体分配足够的空间存储其所有成员，而共用体分配空间仅存储最大的成员。</p><p>例如</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">S</span> &#123;</span><br>  <span class="hljs-keyword">char</span> a;<br>  <span class="hljs-keyword">int</span> b[<span class="hljs-number">4</span>];<br>  <span class="hljs-keyword">double</span> c;<br>&#125; x;<br><br><span class="hljs-keyword">sizeof</span>(x) == <span class="hljs-number">16</span><br></code></pre></div></td></tr></table></figure><p>有一个“字节对齐问题”</p><p>例如</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">U</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">char</span> s[<span class="hljs-number">9</span>];<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-keyword">double</span> d;<br>&#125; x;<br><br><span class="hljs-keyword">sizeof</span>(x) == <span class="hljs-number">16</span><br><br></code></pre></div></td></tr></table></figure><p>其中，s占9字节，n占4字节，d占8字节。但9既不能被4(int)整除，也不能被8(double)整除，因此补充字节到16。</p><p>union大小必须满足：1)大小足够容纳最宽的成员；2)大小能被其包含的所有基本数据类型的大小所整除。</p><h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><h2 id="普通指针"><a href="#普通指针" class="headerlink" title="普通指针"></a>普通指针</h2><p>函数形参有地址时，注意不要改变地址，只改变该地址指向的值以实现双向传输。<br>放个错题：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ArrayCreate</span><span class="hljs-params">(<span class="hljs-keyword">double</span> **<span class="hljs-built_in">array</span>, <span class="hljs-keyword">int</span> size)</span> </span>&#123;<br>    <span class="hljs-built_in">array</span> = (<span class="hljs-keyword">double</span> **)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">double</span> *) * size); <span class="hljs-comment">//wrong</span><br><br>    *<span class="hljs-built_in">array</span> = (<span class="hljs-keyword">double</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">double</span>) * size); <span class="hljs-comment">//right</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>第一种改变会导致该参数的改变无法传出。(这玩意坑了我近两小时)</p><p>静态变量地址可返回使用（返回的指针指向的内存空间没有释放，在主调函数能够继续使用）</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> * <span class="hljs-title">f4</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> d[<span class="hljs-number">10</span>];<br>  <span class="hljs-keyword">return</span> d;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>如果函数的返回类型是指针，则可以返回0。（NULL == 0）</p><p>使用前记得分配空间。</p><h2 id="字符串指针"><a href="#字符串指针" class="headerlink" title="字符串指针"></a>字符串指针</h2><p>两个字符串直接比较 比较的是首地址</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">char</span> *str = <span class="hljs-string">&quot;hello&quot;</span>;<br>str[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;H&#x27;</span>;<br></code></pre></div></td></tr></table></figure><p>这种写法不合法，str指针指向的是常量字符串，不允许修改，会导致<strong>段错误</strong>。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">char</span> *color[<span class="hljs-number">5</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, color[i]);<br></code></pre></div></td></tr></table></figure><p>这种写法亦不合法。段错误。</p><p>字符串数组的数组名不可修改 例如：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">char</span> color[ ][<span class="hljs-number">7</span>] = &#123;<span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-string">&quot;blue&quot;</span>, <span class="hljs-string">&quot;yellow&quot;</span>, <span class="hljs-string">&quot;green&quot;</span>, “black<span class="hljs-string">&quot;&#125;;</span><br><span class="hljs-string">char * tmp = color[0]; </span><br><span class="hljs-string">color[0] = color[4]; </span><br><span class="hljs-string">color[4] = tmp; </span><br></code></pre></div></td></tr></table></figure><p><strong>编译错误！</strong></p><p>字符串处理相关函数(string.h库)</p><table><thead><tr><th align="left">函数名</th><th>功能</th></tr></thead><tbody><tr><td align="left">int strcmp(const char *str1, const char *str2)</td><td>如果返回值小于 0，则表示 str1 小于 str2。</td></tr><tr><td align="left">char *strcat(char *dest, const char *src)</td><td>把 <strong>src</strong> 所指向的字符串追加到 <strong>dest</strong> 所指向的字符串的结尾（dest会被修改）。返回一个指向最终的目标字符串 dest 的指针</td></tr><tr><td align="left">char *strcpy(char *dest, const char *src)</td><td>把 <strong>src</strong> 所指向的字符串复制到 <strong>dest</strong>（dest会被修改），返回一个指向最终的目标字符串 dest 的指针。</td></tr></tbody></table><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>顺带提一句，C语言不允许函数嵌套定义 即一个函数定义中<strong>不可以</strong>完整地包含另一个函数的定义。  </p><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>函数返回类型(*指针变量名)(函数形参类型列表);</p><p>函数名代表函数的入口地址(常量)，是一个指针。通过函数指针可以调用函数，它也可以作为函数的参数。</p><p>放个栗子</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num1,<span class="hljs-keyword">int</span> num2)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> num1 + num2;<br>&#125;<br>​<br>​<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sub</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num1,<span class="hljs-keyword">int</span> num2)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> num1 - num2;<br>&#125;<br>​<br>​<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">calculate</span><span class="hljs-params">(<span class="hljs-keyword">int</span> (*fp)(<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>),<span class="hljs-keyword">int</span> num1,<span class="hljs-keyword">int</span> num2)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> (*fp)(num1,num2);<br>&#125;<br>​<br>​<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;3+5=%d\n&quot;</span>, calculate(add,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;3-5=%d\n&quot;</span>, calculate(sub,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>));<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="数组指针"><a href="#数组指针" class="headerlink" title="数组指针"></a>数组指针</h2><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">int</span> *p[<span class="hljs-number">4</span>];<br><span class="hljs-keyword">int</span> (*p)[<span class="hljs-number">4</span>];<br></code></pre></div></td></tr></table></figure><p>前者为指针数组，p先与<code>[]</code>结合代表其为数组。</p><p>后者为数组指针，p先与<code>*</code>结合代表其为指针，指向的为<code>[4]</code>数组。</p><p>一个小练习：</p><p>变量定义<code>int *(*f[3])();</code>中<code>f</code>是（ ）   D</p><p>A.一组指向返回int的函数的二级指针数组</p><p>B.一个指向一组返回int *的函数数组的指针</p><p>C.一个返回指向一组int *数组的指针的函数</p><p>D.一个返回int *的函数指针的数组</p><p>E.一个指向返回int *数组的函数的指针</p><p>F.一个指向一组返回int的函数指针的数组的指针</p><h2 id="二维数组与指针"><a href="#二维数组与指针" class="headerlink" title="二维数组与指针"></a>二维数组与指针</h2><p>放个栗子</p><p>对于以下程序，能够正确表示二维数组 t 的元素地址的表达式是(C)</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> k, t[<span class="hljs-number">3</span>][<span class="hljs-number">2</span>], *pt[<span class="hljs-number">3</span>];<br>        <br>    <span class="hljs-keyword">for</span> ( k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">3</span>; k++) &#123;<br>        pt[k] = t[k];<br>        &#125;<br>                <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>A. &amp;t[<span class="hljs-number">3</span>][<span class="hljs-number">2</span>]<br>B. *pt[<span class="hljs-number">0</span>]<br>C. *(pt+<span class="hljs-number">1</span>)<br>D. &amp;pt[<span class="hljs-number">2</span>]<br></code></pre></div></td></tr></table></figure><h2 id="指针形参实参匹配"><a href="#指针形参实参匹配" class="headerlink" title="指针形参实参匹配"></a>指针形参实参匹配</h2><p>二维数组名不是二级指针,而是一个数组指针。</p><p>即二维数组的每个元素都是一个一维数组。</p><p>放个栗子 感觉这很难说 也很无聊</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">下列哪些实参(左边)和形参(右边)能够匹配的是（DEFH）。<br>A. <span class="hljs-keyword">double</span> a[<span class="hljs-number">10</span>][<span class="hljs-number">10</span>]<span class="hljs-keyword">double</span> **b<br>B. <span class="hljs-keyword">double</span> a[<span class="hljs-number">10</span>][<span class="hljs-number">10</span>] <span class="hljs-keyword">double</span> b[][]<br>C. <span class="hljs-keyword">double</span> a[<span class="hljs-number">10</span>][<span class="hljs-number">10</span>] <span class="hljs-keyword">double</span> b[<span class="hljs-number">10</span>][]<br>D. <span class="hljs-keyword">double</span> a[<span class="hljs-number">10</span>][<span class="hljs-number">10</span>] <span class="hljs-keyword">double</span> b[][<span class="hljs-number">10</span>]<br>E. <span class="hljs-keyword">double</span> a[<span class="hljs-number">10</span>][<span class="hljs-number">10</span>] <span class="hljs-keyword">double</span> (*b)[<span class="hljs-number">10</span>]<br>F. <span class="hljs-keyword">double</span> *a[<span class="hljs-number">10</span>] <span class="hljs-keyword">double</span> **b<br>G. <span class="hljs-keyword">double</span> (*a)[<span class="hljs-number">10</span>] <span class="hljs-keyword">double</span> **b<br>H. <span class="hljs-keyword">double</span> **a <span class="hljs-keyword">double</span> *b[]<br>I. <span class="hljs-keyword">double</span> **a <span class="hljs-keyword">double</span> b[][]<br></code></pre></div></td></tr></table></figure><p>另外注意有的时候需要对指针强制转换  比如void *很多时候需要转换。</p><h2 id="文件指针"><a href="#文件指针" class="headerlink" title="文件指针"></a>文件指针</h2><blockquote><p><strong>错误</strong>：文件指针指向文件缓冲区中文件数据的存取位置</p></blockquote><blockquote><p>文件指针实际上是指向一个结构体类型的指针，包含有诸如：缓冲区的地址在缓冲区中当前存取的字符的位置、对文件是“读”还是“写”、是否出错、是否已经遇到文件结束标志等信息。</p></blockquote><h3 id="fopen"><a href="#fopen" class="headerlink" title="fopen"></a>fopen</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function">FILE *<span class="hljs-title">fopen</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *filename, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *mode)</span></span><br></code></pre></div></td></tr></table></figure><p>返回一个 FILE 指针。否则返回 <strong>NULL</strong>。</p><p>文件打开方式参数表：</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>r</td><td>只读（文件必须存在）</td></tr><tr><td>w</td><td>只写（若文件不存在则新建）</td></tr><tr><td>a</td><td>追写</td></tr><tr><td>r+</td><td>读写（文件必须存在）</td></tr><tr><td>w+</td><td>读写（若文件不存在则新建）</td></tr><tr><td>a+</td><td>读/追写</td></tr></tbody></table><p>加个b就是相应的二进制文件操作 懒得再赘述。</p><h3 id="feof"><a href="#feof" class="headerlink" title="feof"></a>feof</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">feof</span><span class="hljs-params">(FILE *stream)</span></span><br></code></pre></div></td></tr></table></figure><p>文件结束：返回非0值；文件未结束：返回0值。</p><h3 id="fputc"><a href="#fputc" class="headerlink" title="fputc"></a>fputc</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fputc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> <span class="hljs-keyword">char</span>, FILE *stream)</span></span><br></code></pre></div></td></tr></table></figure><p>如果没有发生错误，则返回被写入的字符。如果发生错误，则返回 EOF。</p><h3 id="rewind"><a href="#rewind" class="headerlink" title="rewind"></a>rewind</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rewind</span><span class="hljs-params">(FILE *stream)</span></span><br></code></pre></div></td></tr></table></figure><p>移到文件首。</p><h3 id="ftell"><a href="#ftell" class="headerlink" title="ftell"></a>ftell</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> <span class="hljs-title">ftell</span><span class="hljs-params">(FILE *stream)</span></span><br></code></pre></div></td></tr></table></figure><p>返回位置标识符的当前值。如果发生错误，则返回 -1L。</p><h3 id="fseek"><a href="#fseek" class="headerlink" title="fseek"></a>fseek</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fseek</span><span class="hljs-params">(FILE *stream, <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">int</span> whence)</span></span><br></code></pre></div></td></tr></table></figure><p>参数：</p><ul><li><strong>stream</strong>  – 这是指向 FILE 对象的指针，该 FILE 对象标识了流。</li><li><strong>offset</strong> – 这是相对 whence 的偏移量，以字节为单位。</li><li><strong>whence</strong> – 这是表示开始添加偏移 offset 的位置。它一般指定为下列常量之一：</li></ul><table><thead><tr><th>常量</th><th>描述</th></tr></thead><tbody><tr><td>SEEK_SET</td><td>文件的开头</td></tr><tr><td>SEEK_CUR</td><td>文件指针的当前位置</td></tr><tr><td>SEEK_END</td><td>文件的末尾</td></tr></tbody></table><h3 id="ferror"><a href="#ferror" class="headerlink" title="ferror"></a>ferror</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">ferror</span><span class="hljs-params">(FILE *stream)</span></span><br></code></pre></div></td></tr></table></figure><p>如果设置了与流关联的错误标识符，该函数返回一个非零值，否则返回一个零值。</p><h3 id="fread"><a href="#fread" class="headerlink" title="fread"></a>fread</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">fread</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *ptr, <span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">size_t</span> nmemb, FILE *stream)</span></span><br></code></pre></div></td></tr></table></figure><p>成功读取的元素总数会以 size_t 对象返回。</p><p>参数：</p><ul><li><strong>ptr</strong>  – 这是指向带有最小尺寸 <em>size*nmemb</em> 字节的内存块的指针。</li><li><strong>size</strong> – 这是要读取的每个元素的大小，以字节为单位。</li><li><strong>nmemb</strong>  – 这是元素的个数，每个元素的大小为 size 字节。</li><li><strong>stream</strong> – 这是指向 FILE 对象的指针，该 FILE 对象指定了一个输入流。</li></ul><h3 id="fwrite"><a href="#fwrite" class="headerlink" title="fwrite"></a>fwrite</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">fwrite</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *ptr, <span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">size_t</span> nmemb, FILE *stream)</span></span><br></code></pre></div></td></tr></table></figure><p>参数：</p><ul><li><strong>ptr</strong>  – 这是指向要被写入的元素数组的指针。</li><li><strong>size</strong>  – 这是要被写入的每个元素的大小，以字节为单位。</li><li><strong>nmemb</strong>  – 这是元素的个数，每个元素的大小为 size 字节。</li><li><strong>stream</strong>  – 这是指向 FILE 对象的指针，该 FILE 对象指定了一个输出流。</li></ul><p>如果成功，该函数返回一个 size_t 对象，表示元素的总数。</p><h1 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h1><h2 id="main"><a href="#main" class="headerlink" title="main"></a>main</h2><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span>;<br></code></pre></div></td></tr></table></figure><p>argc为参数数量，argv为参数列表。<br><strong>文件名本身也算一个参数</strong> 所以argv[0]就是文件名</p><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p>在单向链表中，头指针中存放的不是头结点的内容，头指针指向头结点。（都是些什么无聊的概念）</p><h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p>C语言规定，程序中各函数之间既允许直接递归调用也允许间接递归调用。</p><h1 id="文件包含与工程文件"><a href="#文件包含与工程文件" class="headerlink" title="文件包含与工程文件"></a>文件包含与工程文件</h1><p>放一道题：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">在Dev-C++中创建工程P1，增加main函数所在的project.c，该工程需要使用libgraphics的linkedlist类库，关于linkedlist使用说明正确的有（ ）。ADF<br>    <br>A.通过文件包含将project.c和linkedlist.c连接成一个完整的可执行程序时，可以在project.c中<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;linkedlist.c&quot;</span></span><br>B.通过文件包含将project.c和linkedlist.c连接成一个完整的可执行程序时，可以在project.c中<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;linkedlist.c&quot;</span>，同时工程P1增加linkedlist.h和linkedlist.c</span><br>C.通过工程文件将project.c和linkedlist.c连接成一个完整的可执行程序时，可以在project.c中<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;linkedlist.h&quot;</span></span><br>D.通过工程文件将project.c和linkedlist.c连接成一个完整的可执行程序时，可以在project.c中<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;linkedlist.h&quot;</span>，同时工程P1增加linkedlist.h和linkedlist.c</span><br>E.通过文件包含将project.c和linkedlist.c连接成一个完整的可执行程序时，编译生成project.o和linkedlist.o，连接生成P1.exe<br>F.通过工程文件将project.c和linkedlist.c连接成一个完整的可执行程序时，编译生成project.o和linkedlist.o，连接生成P1.exe<br><br>B.重复包含<br></code></pre></div></td></tr></table></figure><p>文件包含最终是单文件编译，相当于直接把包含的文件代码复制过来</p><p>而工程文件是需要编译连接</p><h1 id="有的没的函数"><a href="#有的没的函数" class="headerlink" title="有的没的函数"></a>有的没的函数</h1><h2 id="qsort"><a href="#qsort" class="headerlink" title="qsort"></a>qsort</h2><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">qsort</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *base, <span class="hljs-keyword">size_t</span> nitems, <span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">int</span> (*compar)(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>*))</span></span><br></code></pre></div></td></tr></table></figure><p>参数：</p><ul><li> <strong>base</strong>  – 指向要排序的数组的第一个元素的指针。</li><li> <strong>nitems</strong>  – 由 base 指向的数组中元素的个数。</li><li> <strong>size</strong>  – 数组中每个元素的大小，以字节为单位。</li><li> <strong>compar</strong>  – 用来比较两个元素的函数。</li></ul><h2 id="sprintf"><a href="#sprintf" class="headerlink" title="sprintf"></a>sprintf</h2><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sprintf</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *str, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *format, ...)</span></span><br></code></pre></div></td></tr></table></figure><p>函数格式化输出成功，返回输出的字符数，<strong>不</strong>包括字符串结束符<code>&#39;\0&#39;</code>，失败则返回一个负整数</p><p>形参str是指向输出缓冲区的指针，函数结束后，格式化的输出结果在缓冲区中，形参format的使用用法与函数printf的形参format相同</p><h2 id="sscanf"><a href="#sscanf" class="headerlink" title="sscanf"></a>sscanf</h2><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sscanf</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *str, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *format, ...)</span></span><br></code></pre></div></td></tr></table></figure><p>形参s指定从中读取数据的字符串，形参format格式字符串，指定了输入的格式，并按照格式说明符解析输入对应位置的信息，并存储于可变参数列表中对应的指针所指位置，使用格式控制字符%n可以获取输入数据所消耗的字符数</p><p>格式化读取成功，返回读取的数据的个数（不包括%n哦），返回值为0表示没有将任何字段赋值，如果读入数据时遇到了“字符串结束”则返回EOF</p><p>例如：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">char</span> buffer[] = <span class="hljs-string">&quot;abc 5 6.7 cde&quot;</span>;<br><span class="hljs-keyword">int</span> a, m, n;<br><span class="hljs-keyword">char</span> str[<span class="hljs-number">4</span>];<br>n = <span class="hljs-built_in">sscanf</span>(buffer, <span class="hljs-string">&quot;%s %d%n&quot;</span>, str, &amp;a, &amp;m);<br><br><span class="hljs-comment">// m = 5, n = 2</span><br></code></pre></div></td></tr></table></figure><h2 id="一些已知宏"><a href="#一些已知宏" class="headerlink" title="一些已知宏"></a>一些已知宏</h2><p>NULL 0</p><p>EOF -1</p><h1 id="奇奇怪怪的东西"><a href="#奇奇怪怪的东西" class="headerlink" title="奇奇怪怪的东西"></a>奇奇怪怪的东西</h1><ul><li><p>正确：一般不能用任何一个文本编辑器打开二进制文件进行阅读。  </p></li><li><p>malloc内存分配时记得强制转换  理论题里认为需要强制转换（虽然C语言允许省略 但C++不大行</p></li></ul><h2 id="register变量"><a href="#register变量" class="headerlink" title="register变量"></a>register变量</h2><p>寄存器变量，其存储于寄存器，速度更快。</p><blockquote><p> 只有局部变量和形式参数才能定义为寄存器变量。</p><p>局部静态变量不能定义为寄存器变量，因为一个变量只能声明为一种存储类别。</p><p>寄存器的长度一般和机器的字长一致，所以，只有较短的类型如int、char、short等才适合定义为寄存器变量，诸如double等较大的类型，不推荐将其定义为寄存器类型。</p><p>CPU的寄存器数目有限，因此，即使定义了寄存器变量，编译器可能并不真正为其分配寄存器，而是将其当做普通的auto变量来对待，为其分配栈内存。当然，有些优秀的编译器，能自动识别使用频繁的变量，如循环控制变量等，在有可用的寄存器时，即使没有使用 register 关键字，也自动为其分配寄存器，无须由程序员来指定。</p></blockquote><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>后面的函数相关笔记来自<a href="https://www.runoob.com/cprogramming/c-tutorial.html">菜鸟教程</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>c</tag>
      
      <tag>note</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>新装Ubuntu后无Wi-Fi图标</title>
    <link href="/Camel_Blog/2022/02/05/%E6%96%B0%E8%A3%85Ubuntu%E5%90%8E%E6%97%A0Wi-Fi%E5%9B%BE%E6%A0%87/"/>
    <url>/Camel_Blog/2022/02/05/%E6%96%B0%E8%A3%85Ubuntu%E5%90%8E%E6%97%A0Wi-Fi%E5%9B%BE%E6%A0%87/</url>
    
    <content type="html"><![CDATA[<p>安装Ubuntu后惊奇地发现莫的Wi-Fi</p><span id="more"></span><p>品牌: 天选2 (ASUS TUF Gaming A15 FA506QM_FA506QM)</p><p>网卡: MediaTek MT7921</p><p>OS: Ubuntu 20.04.3 LTS x86_64</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题:"></a>问题:</h1><p>Ubuntu安装完成后，设置中无Wi-Fi选项卡，找不到无线网卡(好像没有驱动程序)</p><p>似乎只用在较新(2021.6)的电脑型号中会出现这类问题</p><h1 id="解决："><a href="#解决：" class="headerlink" title="解决："></a>解决：</h1><p>(这问题着实困扰了我很久，一直都没法正常使用Ubuntu 连不上Wi-Fi也用不了蓝牙</p><p>为适配最新硬件，需要将Linux内核升级到最新</p><p>刚完成安装的Ubuntu 20.04.3 使用的是5.11内核，无法正常支持MT7921网卡</p><p>因此需要自行更新内核版本(可能有一定风险)</p><blockquote><p>可以暂时选择使用有线网络或者共享网络完成后续安装工作<br>我使用的是手机USB共享网络</p></blockquote><h2 id="查询内核版本"><a href="#查询内核版本" class="headerlink" title="查询内核版本"></a>查询内核版本</h2><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">uname</span> -r<br><span class="hljs-attribute">5</span>.<span class="hljs-number">11</span>.<span class="hljs-number">0</span>-<span class="hljs-number">36</span>-generic<br></code></pre></div></td></tr></table></figure><h2 id="下载安装ubuntu-mainline-kernel-sh脚本"><a href="#下载安装ubuntu-mainline-kernel-sh脚本" class="headerlink" title="下载安装ubuntu-mainline-kernel.sh脚本"></a>下载安装ubuntu-mainline-kernel.sh脚本</h2><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">wget https:<span class="hljs-regexp">//</span>raw.githubusercontent.com<span class="hljs-regexp">/pimlie/u</span>buntu-mainline-kernel.sh<span class="hljs-regexp">/master/u</span>buntu-mainline-kernel.sh<br>sudo install ubuntu-mainline-kernel.sh <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/bin/</span><br></code></pre></div></td></tr></table></figure><p>查看最新内核版本</p><figure class="highlight llvm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs llvm">ubuntu-mainline-kernel.sh -<span class="hljs-keyword">c</span><br></code></pre></div></td></tr></table></figure><p>查看所有可用内核版本</p><figure class="highlight mipsasm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mipsasm">sudo ubuntu-mainline-kernel.<span class="hljs-keyword">sh </span>-r<br></code></pre></div></td></tr></table></figure><h2 id="安装新内核"><a href="#安装新内核" class="headerlink" title="安装新内核"></a>安装新内核</h2><figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus">sudo ubuntu-mainline-kernel<span class="hljs-selector-class">.sh</span> -<span class="hljs-selector-tag">i</span><br><span class="hljs-comment">//或指定安装版本</span><br>sudo ubuntu-mainline-kernel<span class="hljs-selector-class">.sh</span> -<span class="hljs-selector-tag">i</span> <span class="hljs-number">5.12</span>.<span class="hljs-number">11</span><br></code></pre></div></td></tr></table></figure><p>(亲测5.12.11版本内核仍无法解决问题 需要更新的内核版本)</p><p>在默认情况下 重启时系统会默认使用最新的内核</p><p>但也可以在启动系统时选择进入高级模式，指定所需要的内核</p><h2 id="安装固件文件"><a href="#安装固件文件" class="headerlink" title="安装固件文件"></a>安装固件文件</h2><figure class="highlight cmake"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cmake">sudo apt <span class="hljs-keyword">install</span> linux-firmware<br></code></pre></div></td></tr></table></figure><p>问题解决</p><p>不过注意关机后不要立即开机 等待半分钟到一分钟左右</p><p>不然两个系统都无法识别无线网卡(不知道为啥 但影响不大就不管它了)</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://miloserdov.org/?p=6899">https://miloserdov.org/?p=6899</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>ubuntu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GPG相关笔记</title>
    <link href="/Camel_Blog/2022/02/02/GPG%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/"/>
    <url>/Camel_Blog/2022/02/02/GPG%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>GPG相关笔记</p><span id="more"></span><p>GPG配置</p><figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus">gpg --gen-key<span class="hljs-comment">//生成密钥对</span><br>gpg --list-secret-keys --keyid-format LONG<span class="hljs-comment">//列出密钥 包含keyid</span><br>gpg -<span class="hljs-selector-tag">a</span> -o public-file<span class="hljs-selector-class">.key</span> --export keyId <span class="hljs-comment">//导出公钥 -a表示-armor,以ASCII码输出(默认以二进制输出)</span><br>gpg -<span class="hljs-selector-tag">a</span> -o secret-file<span class="hljs-selector-class">.key</span> --export keyId <span class="hljs-comment">//导出私钥</span><br>gpg --import <span class="hljs-selector-class">.key</span> <span class="hljs-comment">//导入公钥或私钥</span><br>gpg --delete-keys keyid     <span class="hljs-comment">//删除公钥</span><br>gpg --delete-secret-keys    <span class="hljs-comment">//删除私钥</span><br>gpg --recipient <span class="hljs-selector-attr">[用户ID]</span> --output demo<span class="hljs-selector-class">.en</span><span class="hljs-selector-class">.txt</span> --encrypt demo<span class="hljs-selector-class">.txt</span><span class="hljs-comment">//加密</span><br>gpg demo<span class="hljs-selector-class">.en</span><span class="hljs-selector-class">.txt</span><span class="hljs-comment">//解密</span><br>gpg --verify demo<span class="hljs-selector-class">.txt</span><span class="hljs-selector-class">.asc</span> demo<span class="hljs-selector-class">.txt</span>  <span class="hljs-comment">//验证签名</span><br></code></pre></div></td></tr></table></figure><p>最后贴两个参考博客</p><p><a href="http://ruanyifeng.com/blog/2013/07/gpg.html">http://ruanyifeng.com/blog/2013/07/gpg.html</a></p><p><a href="https://yexun1995.github.io/2020/09/15/GPG/">https://yexun1995.github.io/2020/09/15/GPG/</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>gpg</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu默认图片查看器打开jpg图片出错</title>
    <link href="/Camel_Blog/2022/02/02/Ubuntu%E9%BB%98%E8%AE%A4%E5%9B%BE%E7%89%87%E6%9F%A5%E7%9C%8B%E5%99%A8%E6%89%93%E5%BC%80jpg%E5%9B%BE%E7%89%87%E5%87%BA%E9%94%99/"/>
    <url>/Camel_Blog/2022/02/02/Ubuntu%E9%BB%98%E8%AE%A4%E5%9B%BE%E7%89%87%E6%9F%A5%E7%9C%8B%E5%99%A8%E6%89%93%E5%BC%80jpg%E5%9B%BE%E7%89%87%E5%87%BA%E9%94%99/</url>
    
    <content type="html"><![CDATA[<p>图片文件无法打开问题</p><span id="more"></span><p><img src="OpenImageError.png" alt="打开时出错"></p><p>如图，打开图片文件时提示<strong>分析JPEG图像文件时出错(Not a JPEG file: starts with 0x89 0x50)</strong></p><p>0x89 0x50开头的文件可能为png格式</p><p>只需将后缀名改为.png即可使用默认图片查看器打开</p>]]></content>
    
    
    
    <tags>
      
      <tag>ubuntu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu下无法使用EasyConnect</title>
    <link href="/Camel_Blog/2022/02/02/Ubuntu%E4%B8%8B%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8EasyConnect/"/>
    <url>/Camel_Blog/2022/02/02/Ubuntu%E4%B8%8B%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8EasyConnect/</url>
    
    <content type="html"><![CDATA[<p>EasyConnect问题</p><span id="more"></span><figure class="highlight elm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs elm"><span class="hljs-title">zhang</span>-yue@zhang-yue:~$ /usr/share/sangfor/<span class="hljs-type">EasyConnect</span>/<span class="hljs-type">EasyConnect</span> <br><span class="hljs-type">Gtk</span>-<span class="hljs-type">Message</span>: <span class="hljs-number">12</span>:<span class="hljs-number">47</span>:<span class="hljs-number">13.670</span>: <span class="hljs-type">Failed</span> to load <span class="hljs-keyword">module</span> &quot;canberra-gtk-<span class="hljs-keyword">module</span>&quot;<br><br>(<span class="hljs-type">EasyConnect</span>:26442): Pango-ERROR **: 12:47:13.802: Harfbuzz version too old (1.3.1)<br><br>追踪与中断点陷阱 (核心已转储)<br></code></pre></div></td></tr></table></figure><h2 id="解决主要矛盾"><a href="#解决主要矛盾" class="headerlink" title="解决主要矛盾"></a>解决主要矛盾</h2><p>错误提示信息是Harfbuzz版本过旧，但<a href="https://www.cnblogs.com/cocode/p/12890684.html">这篇博客</a>说其实是pango版本过新</p><p>所以需要降级pango 但又不能影响系统库 只需将相关依赖直接放在EasyConnect目录下</p><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">zhang</span>-yue@zhang-yue:/usr/share/sangfor/EasyConnect$ ldd EasyConnect | grep pango<br><span class="hljs-attribute">libpangocairo</span>-<span class="hljs-number">1</span>.<span class="hljs-number">0</span>.so.<span class="hljs-number">0</span> =&gt; /lib/x<span class="hljs-number">86</span>_<span class="hljs-number">64</span>-linux-gnu/libpangocairo-<span class="hljs-number">1</span>.<span class="hljs-number">0</span>.so.<span class="hljs-number">0</span> (<span class="hljs-number">0</span>x<span class="hljs-number">00007</span>f<span class="hljs-number">7</span>fa<span class="hljs-number">0</span>cee<span class="hljs-number">000</span>)<br><span class="hljs-attribute">libpango</span>-<span class="hljs-number">1</span>.<span class="hljs-number">0</span>.so.<span class="hljs-number">0</span> =&gt; /lib/x<span class="hljs-number">86</span>_<span class="hljs-number">64</span>-linux-gnu/libpango-<span class="hljs-number">1</span>.<span class="hljs-number">0</span>.so.<span class="hljs-number">0</span> (<span class="hljs-number">0</span>x<span class="hljs-number">00007</span>f<span class="hljs-number">7</span>fa<span class="hljs-number">0</span>b<span class="hljs-number">54000</span>)<br><span class="hljs-attribute">libpangoft2</span>-<span class="hljs-number">1</span>.<span class="hljs-number">0</span>.so.<span class="hljs-number">0</span> =&gt; /lib/x<span class="hljs-number">86</span>_<span class="hljs-number">64</span>-linux-gnu/libpangoft<span class="hljs-number">2</span>-<span class="hljs-number">1</span>.<span class="hljs-number">0</span>.so.<span class="hljs-number">0</span> (<span class="hljs-number">0</span>x<span class="hljs-number">00007</span>f<span class="hljs-number">7</span>f<span class="hljs-number">9</span>eea<span class="hljs-number">9000</span>)<br></code></pre></div></td></tr></table></figure><p>不难发现，涉及到的so文件只有这么几个</p><p>只需到<a href="https://packages.ubuntu.com/">这里</a>下载相关<code>低版本</code>依赖(按照<a href="https://programmerah.com/error-report-when-running-under-easyconnect-linux-ubuntu-20-04-46024/">这里</a>的说法应该是低于1.42的版本即可)</p><blockquote><p><a href="https://packages.ubuntu.com/bionic-updates/libpango-1.0-0">libpango-1.0-0_1.40.14-1ubuntu0.1_amd64.deb</a></p></blockquote><blockquote><p><a href="https://packages.ubuntu.com/bionic-updates/libpangocairo-1.0-0">libpangocairo-1.0-0_1.40.14-1ubuntu0.1_amd64.deb</a></p></blockquote><blockquote><p><a href="https://packages.ubuntu.com/bionic-updates/libpangoft2-1.0-0">libpangoft2-1.0-0_1.40.14-1ubuntu0.1_amd64.deb</a></p></blockquote><p>解压后将***.so和***.so.***两个文件移入/usr/share/sangfor/EasyConnect/即可(这俩文件在解压后的data/usr/lib/x86_64-linux-gnu中)</p><p>(听说似乎.so文件相当于windows的.dll文件)</p><h2 id="还有一个小问题"><a href="#还有一个小问题" class="headerlink" title="还有一个小问题"></a>还有一个小问题</h2><p>至此easyconnect总算是跑起来了 至少能看到图形界面了(心累)</p><p>然后就是来解决<code>Failed to load module &quot;canberra-gtk-module&quot;</code>的问题了</p><p>参考<a href="https://blog.csdn.net/h106140873/article/details/114263954">这里</a>的方法</p><figure class="highlight arduino"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arduino">sudo apt install libcanberra-gtk-<span class="hljs-keyword">module</span><br></code></pre></div></td></tr></table></figure><p>芜湖 终于完事了(就是不知为何这玩意打开的速度有点慢)</p>]]></content>
    
    
    
    <tags>
      
      <tag>easyconnect</tag>
      
      <tag>ubuntu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu终端命令笔记</title>
    <link href="/Camel_Blog/2022/01/19/Ubuntu%E7%BB%88%E7%AB%AF%E5%91%BD%E4%BB%A4%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/"/>
    <url>/Camel_Blog/2022/01/19/Ubuntu%E7%BB%88%E7%AB%AF%E5%91%BD%E4%BB%A4%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>Ubuntu终端命令相关笔记</p><span id="more"></span><h1 id="系统相关"><a href="#系统相关" class="headerlink" title="系统相关"></a>系统相关</h1><h2 id="硬件架构"><a href="#硬件架构" class="headerlink" title="硬件架构"></a>硬件架构</h2><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">uname -a<br><br>arch<br>//x86_64<br></code></pre></div></td></tr></table></figure><p>(听说x86_64,x64,AMD64基本上是同一个东西)</p>]]></content>
    
    
    
    <tags>
      
      <tag>note</tag>
      
      <tag>ubuntu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang之旅</title>
    <link href="/Camel_Blog/2022/01/19/Golang%E4%B9%8B%E6%97%85/"/>
    <url>/Camel_Blog/2022/01/19/Golang%E4%B9%8B%E6%97%85/</url>
    
    <content type="html"><![CDATA[<p>Golang学习笔记</p><span id="more"></span><h1 id="安装-amp-配置"><a href="#安装-amp-配置" class="headerlink" title="安装&amp;配置"></a>安装&amp;配置</h1><h2 id="安装环境报错"><a href="#安装环境报错" class="headerlink" title="安装环境报错"></a>安装环境报错</h2><p>go安装环境报错：</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">Installing github.com<span class="hljs-regexp">/uudashr/g</span>opkgs<span class="hljs-regexp">/v2/</span>cmd/gopkgs FAILED<br></code></pre></div></td></tr></table></figure><p>解决：</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">go env -w <span class="hljs-attribute">GO111MODULE</span>=on<br>go env -w <span class="hljs-attribute">GOPROXY</span>=https://goproxy.io,direct<br></code></pre></div></td></tr></table></figure><hr><h2 id="Go配置"><a href="#Go配置" class="headerlink" title="Go配置"></a>Go配置</h2><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">sudo vim <span class="hljs-regexp">/etc/</span>profile<br></code></pre></div></td></tr></table></figure><p>在文件尾添加</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros"><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">GOPATH</span>=/home/zhang-yue/工作路径<br><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">GOROOT</span>=/usr/zhang-yue/go安装路径<br><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">PATH</span>=<span class="hljs-variable">$PATH</span>:$GOROOT/bin:$GOPATH/bin<br></code></pre></div></td></tr></table></figure><p>关闭后通过</p><figure class="highlight vim"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vim"><span class="hljs-keyword">source</span> /etc/<span class="hljs-keyword">profile</span><br><span class="hljs-keyword">go</span> <span class="hljs-keyword">version</span><br></code></pre></div></td></tr></table></figure><p>重启即可</p><h1 id="Go语法基础"><a href="#Go语法基础" class="headerlink" title="Go语法基础"></a>Go语法基础</h1><p>下面开始快速入门golang(从入门到入坟)</p><ul><li>golang语句后不必加分号</li></ul><h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><ul><li><p>每个Go程序都是由包构成 程序从main包开始运行。</p></li><li><p>在Go中，如果一个名字以大写字母开头，那么它就是可导出的。(例如fmt.Println P大写)</p></li><li><p>在导入一个包时，您只能引用已导出的名字，任何未导出的名字在该包外均无法访问</p></li></ul><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul><li><p>声明格式</p>  <figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">(x,y <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-keyword">return</span> x+y<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>注意：与C不同的是 Go在声明函数时函数返回值类型在最后 具体原因在<a href="https://blog.go-zh.org/gos-declaration-syntax">这里</a></p></blockquote><blockquote><p>(主要是为了增加可读性吧)</p></blockquote></li><li><p>函数可以有任意多的返回值 且返回值可被命名</p><p>  对于没有参数的<code>return</code>语句 将直接返回已命名的返回值 在长程序中应避免直接返回</p><p>  例如</p>  <figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">(x,y <span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(sum <span class="hljs-keyword">int</span>)</span></span> &#123;<br>    sum = x+y<br>    <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><ul><li><p>在函数外必须使用<code>var</code>关键字声明变量</p></li><li><p>在函数内可使用<code>:=</code>简洁赋值语句代替<code>var</code>声明</p></li><li><p>与C不同的是，Go在不同类型变量间赋值时必须使用显式转换</p></li></ul><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><ul><li><p>常量声明使用<code>const</code>关键字</p></li><li><p>常量可以是字符、字符串、布尔值或数值</p></li><li><p>常量不能用<code>:=</code>声明</p></li><li><p>数值常量是高精度的值</p>  <figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Go"><span class="hljs-keyword">const</span> (<br>    Big = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">100</span><br>    <span class="hljs-comment">//Big的二进制是1后面跟着100个0</span><br>    <span class="hljs-comment">//直接输出将会溢出</span><br>)<br></code></pre></div></td></tr></table></figure></li></ul><h2 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h2><h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><ul><li><p>基本格式</p>  <figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Go"><span class="hljs-keyword">if</span> x &lt; <span class="hljs-number">0</span> &#123;<br>    <span class="hljs-comment">//do something</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>  与C不同的是:表达式外无需小括号</p></li><li><p>if语句可以在条件表达式前执行一个简单语句<br>  该语句声明的变量作用域在if内</p>  <figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Go"><span class="hljs-keyword">if</span> x := <span class="hljs-number">5</span>; x &lt; <span class="hljs-number">10</span> &#123;<br>    <span class="hljs-comment">//do something</span><br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul><h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><ul><li><p>基本格式</p>  <figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;runtime&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Print(<span class="hljs-string">&quot;Go runs on &quot;</span>)<br>    <span class="hljs-keyword">switch</span> os := runtime.GOOS; os &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;darwin&quot;</span>:<br>        fmt.Println(<span class="hljs-string">&quot;OS X.&quot;</span>)<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;linux&quot;</span>:<br>        fmt.Println(<span class="hljs-string">&quot;Linux.&quot;</span>)<br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-comment">// freebsd, openbsd,</span><br>        <span class="hljs-comment">// plan9, windows...</span><br>        fmt.Printf(<span class="hljs-string">&quot;%s.\n&quot;</span>, os)<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>Go只运行选定的case，相当于在每个case后自动加了break<br>但可使用fallthrough强制执行后续case</p></li><li><p>case后无需为常量 取值不必为整数</p></li><li><p>case语句从上到下匹配</p></li><li><p>没有条件的switch相当于一长串的if-then-else</p>  <figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    t := time.Now()<br>    <span class="hljs-keyword">switch</span> &#123;<br>    <span class="hljs-keyword">case</span> t.Hour() &lt; <span class="hljs-number">12</span>:<br>        fmt.Println(<span class="hljs-string">&quot;Good morning!&quot;</span>)<br>    <span class="hljs-keyword">case</span> t.Hour() &lt; <span class="hljs-number">17</span>:<br>        fmt.Println(<span class="hljs-string">&quot;Good afternoon.&quot;</span>)<br>    <span class="hljs-keyword">default</span>:<br>        fmt.Println(<span class="hljs-string">&quot;Good evening.&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul><h3 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h3><ul><li><p>defer语句会将函数推迟到外层函数返回之后执行 但其参数会立即求值</p></li><li><p>推迟的函数调用会被压入一个栈中 在外层函数返回后按照后进先出顺序调用</p></li></ul><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><ul><li>基本格式  <figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Go"><span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; i++ &#123;<br>    sum += i<br>&#125;<br></code></pre></div></td></tr></table></figure>  与C语言不同，Go的for语句后的三个部分外没有小括号</li></ul><h3 id="“while”"><a href="#“while”" class="headerlink" title="“while”"></a>“while”</h3><ul><li>C的while在Go中叫做for</li><li>基本格式  <figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Go"><span class="hljs-keyword">for</span> sum&lt;<span class="hljs-number">1000</span> &#123;<br>    sum += sum<br>&#125;<br></code></pre></div></td></tr></table></figure>  在”while”条件前后加上两个分号即为标准的for语句  <figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Go"><span class="hljs-keyword">for</span> ;sum&lt;<span class="hljs-number">1000</span>; &#123;<br>    sum += sum<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul><h3 id="无限循环"><a href="#无限循环" class="headerlink" title="无限循环"></a>无限循环</h3><ul><li>只需省略循环条件  <figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Go"><span class="hljs-keyword">for</span> &#123;<br><br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul><h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><ul><li><p>结构体指针允许隐式间接引用(这是什么鬼话 看下面例子</p><p>  例如</p><p>  有一个指向结构体的指针p 那么在C语言中可以通过<code>(*p).X</code>来访问其字段X</p><p>  在go中允许通过<code>p.x</code>来访问</p></li><li><p>这边放一个结构体的例子用来看语法</p>  <figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">type</span> Vertex <span class="hljs-keyword">struct</span> &#123;<br>    X, Y <span class="hljs-keyword">int</span><br>&#125;<br><br><span class="hljs-keyword">var</span> (<br>    v1 = Vertex&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;  <span class="hljs-comment">// 创建一个 Vertex 类型的结构体</span><br>    v2 = Vertex&#123;X: <span class="hljs-number">1</span>&#125;  <span class="hljs-comment">// Y:0 被隐式地赋予</span><br>    v3 = Vertex&#123;&#125;      <span class="hljs-comment">// X:0 Y:0</span><br>    p  = &amp;Vertex&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125; <span class="hljs-comment">// 创建一个 *Vertex 类型的结构体（指针）</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println(v1, p, v2, v3)<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul><h2 id="数组与切片"><a href="#数组与切片" class="headerlink" title="数组与切片"></a>数组与切片</h2><ul><li><p>数组声明</p>  <figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> a [<span class="hljs-number">10</span>]<span class="hljs-keyword">int</span><br></code></pre></div></td></tr></table></figure></li><li><p>切片声明</p>  <figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">   primes := [<span class="hljs-number">6</span>]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">11</span>, <span class="hljs-number">13</span>&#125;<br><br><span class="hljs-keyword">var</span> s []<span class="hljs-keyword">int</span> = primes[<span class="hljs-number">1</span>:<span class="hljs-number">4</span>]<br></code></pre></div></td></tr></table></figure><p>  切片提供动态大小</p><p>  例中1:4为半开区间 左闭右开</p></li><li><p>切片不存储任何数据 更改切片会修改底层数组</p></li><li><p>切片拥有<strong>长度</strong>和<strong>容量</strong>。</p><p>  切片的长度就是它所包含的元素个数。</p><p>  切片的容量是从它的第一个元素开始数，到其底层数组元素末尾的个数。</p><p>  切片 s 的长度和容量可通过表达式<code>len(s)</code>和<code>cap(s)</code>来获取。</p>  <figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">   <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>s := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">11</span>, <span class="hljs-number">13</span>&#125;<br>   <span class="hljs-comment">//len=6 cap=6 [2 3 5 7 11 13]</span><br><br><span class="hljs-comment">// 截取切片使其长度为 0</span><br>s = s[:<span class="hljs-number">0</span>]<br>   <span class="hljs-comment">//len=0 cap=6 []</span><br><br><span class="hljs-comment">// 拓展其长度</span><br>s = s[:<span class="hljs-number">4</span>]<br>   <span class="hljs-comment">//len=4 cap=6 [2 3 5 7]</span><br><br><span class="hljs-comment">// 舍弃前两个值</span><br>s = s[<span class="hljs-number">2</span>:]<br>   <span class="hljs-comment">//len=2 cap=4 [5 7]</span><br>   &#125;<br></code></pre></div></td></tr></table></figure><p>  拓展长度时超过容量会引发<strong>panic</strong></p></li><li><p>切片的零值为<code>nil</code></p>  <figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nil```切片的长度和容量均为0且没有底层数组"><br>- 可用make函数创建切片<br>    ```go<br>    a := make([]int, 5) //len(a)=5<br><br>    a := make([]int, 0, 5) //len(a)=0,cap(a)=5<br></code></pre></div></td></tr></table></figure></li><li><p>切片可包含任意类型</p><p>  切片的切片</p>  <figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;strings&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 创建一个井字板（经典游戏）</span><br>    board := [][]<span class="hljs-keyword">string</span>&#123;<br>        []<span class="hljs-keyword">string</span>&#123;<span class="hljs-string">&quot;_&quot;</span>, <span class="hljs-string">&quot;_&quot;</span>, <span class="hljs-string">&quot;_&quot;</span>&#125;,<br>        []<span class="hljs-keyword">string</span>&#123;<span class="hljs-string">&quot;_&quot;</span>, <span class="hljs-string">&quot;_&quot;</span>, <span class="hljs-string">&quot;_&quot;</span>&#125;,<br>        []<span class="hljs-keyword">string</span>&#123;<span class="hljs-string">&quot;_&quot;</span>, <span class="hljs-string">&quot;_&quot;</span>, <span class="hljs-string">&quot;_&quot;</span>&#125;,<br>    &#125;<br><br>    <span class="hljs-comment">// 两个玩家轮流打上 X 和 O</span><br>    board[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;X&quot;</span><br>    board[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>] = <span class="hljs-string">&quot;O&quot;</span><br>    board[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>] = <span class="hljs-string">&quot;X&quot;</span><br>    board[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;O&quot;</span><br>    board[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>] = <span class="hljs-string">&quot;X&quot;</span><br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(board); i++ &#123;<br>        fmt.Printf(<span class="hljs-string">&quot;%s\n&quot;</span>, strings.Join(board[i], <span class="hljs-string">&quot; &quot;</span>))<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul><h2 id="Panic"><a href="#Panic" class="headerlink" title="Panic"></a>Panic</h2><p><a href="https://www.cnblogs.com/yuxiaoba/p/9813605.html">参考博客</a></p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;errors&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;Enter function main.&quot;</span>)<br>    <span class="hljs-built_in">panic</span>(errors.New(<span class="hljs-string">&quot;something wrong&quot;</span>)) <span class="hljs-comment">// 引发 panic</span><br>    p := <span class="hljs-built_in">recover</span>()<br>    fmt.Printf(<span class="hljs-string">&quot;panic: %s\n&quot;</span>, p)<br>    fmt.Println(<span class="hljs-string">&quot;Exit function main.&quot;</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>此程序recover()不会执行  引发panic后(控制权会沿着调用栈反方向传播)，后续程序不再执行</p><p><code>正确用法</code></p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;errors&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;Enter function main.&quot;</span>)<br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>&#123;<br>        fmt.Println(<span class="hljs-string">&quot;Enter defer function.&quot;</span>)<br>        <span class="hljs-keyword">if</span> p := <span class="hljs-built_in">recover</span>(); p != <span class="hljs-literal">nil</span> &#123;<br>        fmt.Printf(<span class="hljs-string">&quot;panic: %s\n&quot;</span>, p)<br>        &#125;<br>        fmt.Println(<span class="hljs-string">&quot;Exit defer function.&quot;</span>)<br>    &#125;()<br>    <span class="hljs-built_in">panic</span>(errors.New(<span class="hljs-string">&quot;something wrong&quot;</span>)) <span class="hljs-comment">// 引发 panic。</span><br>    fmt.Println(<span class="hljs-string">&quot;Exit function main.&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">//运行结果</span><br>Enter function main.<br>Enter <span class="hljs-keyword">defer</span> function.<br><span class="hljs-built_in">panic</span>: something wrong<br>Exit <span class="hljs-keyword">defer</span> function.<br></code></pre></div></td></tr></table></figure><p>当一个函数即将结束执行时，写在最下面的defer函数调用会最先执行，其次是写在它上边的与它距离最近的defer函数调用，以此类推。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-string">&quot;first defer&quot;</span>)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++ &#123;<br>        <span class="hljs-keyword">defer</span> fmt.Printf(<span class="hljs-string">&quot;defer in for [%d]\n&quot;</span>, i)<br>    &#125;<br>    <span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-string">&quot;last defer&quot;</span>)<br>&#125;<br><br><br><span class="hljs-comment">//运行结果</span><br>last <span class="hljs-keyword">defer</span><br><span class="hljs-keyword">defer</span> in <span class="hljs-keyword">for</span> [<span class="hljs-number">2</span>]<br><span class="hljs-keyword">defer</span> in <span class="hljs-keyword">for</span> [<span class="hljs-number">1</span>]<br><span class="hljs-keyword">defer</span> in <span class="hljs-keyword">for</span> [<span class="hljs-number">0</span>]<br>first <span class="hljs-keyword">defer</span><br></code></pre></div></td></tr></table></figure><h1 id="swagger-UI-相关"><a href="#swagger-UI-相关" class="headerlink" title="swagger-UI 相关"></a>swagger-UI 相关</h1><p>编写完注释后记得运行以下<code>swag init</code>来生成接口文档数据(忘了两次了)</p><blockquote><p>安装swag:<code>go get -u github.com/swaggo/swag/cmd/swag</code></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>note</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>美化Ubuntu</title>
    <link href="/Camel_Blog/2022/01/14/%E7%BE%8E%E5%8C%96Ubuntu/"/>
    <url>/Camel_Blog/2022/01/14/%E7%BE%8E%E5%8C%96Ubuntu/</url>
    
    <content type="html"><![CDATA[<p>默认的主题有点丑 需要亿点点美化</p><span id="more"></span><h1 id="gnome"><a href="#gnome" class="headerlink" title="gnome"></a>gnome</h1><p>安装相关工具</p><figure class="highlight mipsasm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mipsasm">sudo apt <span class="hljs-keyword">install </span>gnome-tweak-tool<br>sudo apt <span class="hljs-keyword">install </span>gnome-<span class="hljs-keyword">shell-extensions</span><br><span class="hljs-keyword"></span>sudo apt <span class="hljs-keyword">install </span>chrome-gnome-<span class="hljs-keyword">shell</span><br></code></pre></div></td></tr></table></figure><p><a href="https://extensions.gnome.org/">gnome官方插件中心</a></p><p>打开</p><figure class="highlight ebnf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">gnome-tweaks</span><br></code></pre></div></td></tr></table></figure><blockquote><p>重启gnome只需alt+F2 输入r即可</p></blockquote><h1 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h1><ul><li>dash to dock<blockquote><p>更改dock栏 需隐藏原有dock栏</p></blockquote><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">cd <span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/gnome-shell/</span>extensions<br>sudo mv ubuntu-dock@ubuntu.com ../<br></code></pre></div></td></tr></table></figure></li></ul><h1 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h1><p>GTK Theme: 构建应用程序的图形用户界面的框架</p><p>Gnome Shell Theme: Shell元素主题</p><p><a href="https://www.gnome-look.org/s/Gnome/browse/">gnome主题下载</a></p><p><a href="https://www.gnome-look.org/s/Gnome/p/1220749">Canta theme</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>ubuntu</tag>
      
      <tag>gnome</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>博客搭建</title>
    <link href="/Camel_Blog/2022/01/12/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    <url>/Camel_Blog/2022/01/12/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<p>使用linux时发现乱七八糟的指令有点多，所以搞了个博客来记录一下下。 </p><span id="more"></span><h1 id="相关软件安装"><a href="#相关软件安装" class="headerlink" title="相关软件安装"></a>相关软件安装</h1><p>添加nodejs源 </p><figure class="highlight vim"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vim">sudo curl -sL http<span class="hljs-variable">s:</span>//<span class="hljs-keyword">deb</span>.nodesource.<span class="hljs-keyword">com</span>/setup_14.<span class="hljs-keyword">x</span> | sudo -E bash -<br></code></pre></div></td></tr></table></figure><p>安装node.js </p><figure class="highlight cmake"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cmake">sudo apt <span class="hljs-keyword">install</span> nodejs<br></code></pre></div></td></tr></table></figure><p>安装hexo(-g为全局安装)</p><figure class="highlight cmake"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cmake">sudo npm <span class="hljs-keyword">install</span> -g hexo<br></code></pre></div></td></tr></table></figure><h1 id="本地创建博客"><a href="#本地创建博客" class="headerlink" title="本地创建博客"></a>本地创建博客</h1><p>初始化创建 </p><figure class="highlight cmake"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cmake">hexo init<br>npm <span class="hljs-keyword">install</span><br></code></pre></div></td></tr></table></figure><p>清除所有记录</p><figure class="highlight ebnf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo clean</span><br></code></pre></div></td></tr></table></figure><p>生成静态网页</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">hexo <span class="hljs-keyword">generate</span><br></code></pre></div></td></tr></table></figure><p>启动服务(-p表示端口 默认4000)</p><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">hexo</span> server -p <span class="hljs-number">80</span><br></code></pre></div></td></tr></table></figure><h1 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h1><p>下载的主题放在themes中<br>并将_config.yml中theme:后的名字改掉 </p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">hexo clean<br>hexo <span class="hljs-keyword">generate</span><br>hexo server<br></code></pre></div></td></tr></table></figure><h1 id="上传到gitee"><a href="#上传到gitee" class="headerlink" title="上传到gitee"></a>上传到gitee</h1><p>在_config.yml补充deploy部分</p><figure class="highlight dts"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dts"><span class="hljs-symbol">deploy:</span><br><span class="hljs-symbol">  type:</span> git<br><span class="hljs-symbol">  repo:</span> git@gitee.com:Zhang_Yue0621/camel_blog.git  <span class="hljs-meta">#仓库的地址</span><br><span class="hljs-symbol">  branch:</span> master<br></code></pre></div></td></tr></table></figure><p>安装插件</p><figure class="highlight ada"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ada">npm install hexo-deployer-git <span class="hljs-comment">--save</span><br></code></pre></div></td></tr></table></figure><p>上传！</p><figure class="highlight ebnf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo deploy</span><br></code></pre></div></td></tr></table></figure><h1 id="hexo常用命令整理"><a href="#hexo常用命令整理" class="headerlink" title="hexo常用命令整理"></a>hexo常用命令整理</h1><figure class="highlight axapta"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs axapta">hexo <span class="hljs-keyword">new</span> <span class="hljs-string">&quot;postname&quot;</span> <span class="hljs-meta">#新建文章</span><br>hexo <span class="hljs-keyword">new</span> page <span class="hljs-string">&quot;pagename&quot;</span><span class="hljs-meta">#新建页面</span><br>hexo d <span class="hljs-meta">#上传 等价于hexo deploy </span><br>hexo g <span class="hljs-meta">#生成静态网页 等价于hexo generate </span><br>hexo s <span class="hljs-meta">#本地部署 等价于hexo server </span><br></code></pre></div></td></tr></table></figure><h1 id="撰写博客"><a href="#撰写博客" class="headerlink" title="撰写博客"></a>撰写博客</h1><p>摘要和正文使用<code>&lt;!--more--&gt;</code>隔开<br>标签使用如下形式</p><figure class="highlight subunit"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs subunit"><span class="hljs-keyword">tags:</span> <br>    - hexo<br>    - fluid<br>    - blog<br></code></pre></div></td></tr></table></figure><h1 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h1><p>打开根目录下_config.yml</p><p>将post_asset_folder改为true</p><p>此时每次新建文章时将会自动创建同名文件夹用于存放图片</p><p>安装插件<code>npm install hexo-asset-img</code></p><blockquote><p>使用hexo-asset-image插件时转换后的地址错误 无法使用</p></blockquote><blockquote><p>几经周折后发现了hexo-asset-img插件可以正常工作</p></blockquote><p>写博客时只需根据markdown语法<code>![title](xxx.png)</code>即可</p><p><a href="https://moeci.com/posts/hexo-typora/">参考博客</a></p><p><a href="https://github.com/yiyungent/hexo-asset-img">github地址</a></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://kaiter-plus.gitee.io/2020/03/07/How_To_Freely_Build_Blog/">搭建博客</a> </p><p><a href="https://github.com/fluid-dev/hexo-theme-fluid">fluid主题</a> </p><p><a href="https://blog.csdn.net/weixin_49270402/article/details/117672195">主题配置</a> </p>]]></content>
    
    
    
    <tags>
      
      <tag>blog</tag>
      
      <tag>hexo</tag>
      
      <tag>fluid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C小程错题整理</title>
    <link href="/Camel_Blog/2022/01/07/C%E5%B0%8F%E7%A8%8B%E9%94%99%E9%A2%98%E6%95%B4%E7%90%86/"/>
    <url>/Camel_Blog/2022/01/07/C%E5%B0%8F%E7%A8%8B%E9%94%99%E9%A2%98%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>C小程的错题整理</p><span id="more"></span><h2 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h2><ul><li><p>C程序中定义的变量，代表内存中的一个存储单元。  True</p></li><li><p>执行以下程序段，<code>sum</code>的值是55。 False</p>  <figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-keyword">int</span> i, sum;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; i++)&#123;<br>    sum = sum + i;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>C语言中的所有语句都必须以分号结束。   True</p></li><li><p>若变量已正确定义，执行以下<code>while</code>语句将陷入死循环。 False</p>  <figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C">i = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (i &lt;= <span class="hljs-number">10</span>) ;<br>    i++;<br></code></pre></div></td></tr></table></figure></li><li><p>以下程序段的功能是输出1～100之间每个整数的各位数字之和。  False(死循环)</p>  <figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-keyword">for</span>(num = <span class="hljs-number">1</span>; num &lt;= <span class="hljs-number">100</span>; num++)&#123; <br>    s = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">do</span>&#123;<br>        s = s + num % <span class="hljs-number">10</span>;<br>        num = num / <span class="hljs-number">10</span>;<br>    &#125;<span class="hljs-keyword">while</span>(num != <span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, s); <br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p><code>08</code>是正确的整型常量。    False</p></li><li><p>表达式<code>~(~2&lt;&lt;1)</code>的值是5。    True</p></li><li><p>表达式<code>(z=0, (x=2)||(z=1),z)</code>的值是1。  False</p></li><li><p>运算符<code>“+”</code>不能作为单目运算符。   False</p></li><li><p>自动变量如果没有赋值，其值被自动赋为0。 False   （auto != statics)</p></li><li><p>为了检查以下省略<code>else</code>的<code>if</code>语句的分支是否正确，至少需要设计3组测试用例，即<code>grade</code>的取值至少有三组（小于、大于、等于60）。   </p>  <figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-keyword">if</span>(grade &lt; <span class="hljs-number">60</span>)&#123;    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Fail\n&quot;</span>); <br>&#125;<br></code></pre></div></td></tr></table></figure><p>  True    (需检查边界值)</p></li><li><p>C语言中，大小写字母<code>&#39;A&#39;，&#39;B&#39;，&#39;C&#39;，…，&#39;Z&#39; ，&#39;a&#39;，&#39;b&#39;，&#39;c&#39;，…，&#39;z&#39;</code>的ASCII码按升序连续排列。</p><p>  False   (连续?)</p></li><li><p>设变量已正确定义，执行以下程序段，顺序输入三个字符<code>&#39;Q&#39;</code>，则输出Q。 </p>  <figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C">ch = getchar(); <br><span class="hljs-built_in">putchar</span>(ch); <br></code></pre></div></td></tr></table></figure><p>  False   (三个字符<code>&#39;Q&#39;</code>)</p></li><li><p>一维数组定义的一般形式如下：</p>  <figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C">类型名 数组名[数组长度]；<br></code></pre></div></td></tr></table></figure><p>  数组元素引用的一般形式如下：</p>  <figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C">数组名[下标]<br></code></pre></div></td></tr></table></figure><p>  在引用数组元素时，下标的合理取值范围是[0，数组长度-1]，下标不能越界。</p><p>  True</p></li><li><p>二维数组定义的一般形式如下，其中的类型名指定数组名的类型。</p>  <figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C">类型名 数组名[行长度][列长度]；<br></code></pre></div></td></tr></table></figure><p>  False   (类型名指定数组中每个元素的类型)</p></li><li><p>二维数组定义的一般形式如下，其中的行长度和列长度都是整型常量表达式。</p>  <figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C">类型名 数组名[行长度] [列长度]；<br></code></pre></div></td></tr></table></figure><p>  True (允许空格、换行)</p></li></ul><hr><ul><li><p>引用二维数组的元素要指定两个下标，即行下标和列下标，一般形式如下。</p>  <figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C">数组名[列下标][行下标]<br></code></pre></div></td></tr></table></figure><p>  False</p></li><li><p>假设结构指针p已定义并正确赋值，其指向的结构变量有一个成员是int型的num，则语句<code>*p.num = 100; </code>是正确的。   False(优先级)</p></li><li><p>表达式 (z=0, (x=2)||(z=1),z) 的值是1。 False(短路)</p></li><li><p>运行包含以下代码段的程序将可能进入死循环。</p>  <figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>；<br><span class="hljs-keyword">while</span>(i&gt;<span class="hljs-number">0</span>)&#123; i++; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,i); &#125;<br></code></pre></div></td></tr></table></figure><p>  False(溢出)</p></li></ul><h2 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h2><ul><li><p>(多)以下程序段（ ）的功能是：输入一批整数，用负数作为输入的结束标志，统计其中大于<code>85</code>的数据个数。   AD</p>  <figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C">A.<br>    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>, score;<br>    <span class="hljs-built_in">scanf</span> (<span class="hljs-string">&quot;%d&quot;</span>, &amp;score);<br>    <span class="hljs-keyword">while</span>(score &gt;= <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">if</span>(score &gt; <span class="hljs-number">85</span>)&#123;<br>            count++;<br>        &#125;<br>        <span class="hljs-built_in">scanf</span> (<span class="hljs-string">&quot;%d&quot;</span>, &amp;score);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, count);<br>B.<br>    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>, score;<br>    <span class="hljs-built_in">scanf</span> (<span class="hljs-string">&quot;%d&quot;</span>, &amp;score);<br>    <span class="hljs-keyword">while</span>(score &gt;= <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">scanf</span> (<span class="hljs-string">&quot;%d&quot;</span>, &amp;score);<br>        <span class="hljs-keyword">if</span>(score &gt; <span class="hljs-number">85</span>)&#123;<br>            count++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, count);<br>C.<br>    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>, score;<br>    <span class="hljs-keyword">while</span>(score &gt;= <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">scanf</span> (<span class="hljs-string">&quot;%d&quot;</span>, &amp;score);<br>        <span class="hljs-keyword">if</span>(score &gt; <span class="hljs-number">85</span>)&#123;<br>            count++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, count);<br>D.<br>    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>, score;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-built_in">scanf</span> (<span class="hljs-string">&quot;%d&quot;</span>, &amp;score);<br>        <span class="hljs-keyword">if</span>(score &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">if</span>(score &gt; <span class="hljs-number">85</span>)&#123;<br>            count++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, count);<br></code></pre></div></td></tr></table></figure></li><li><p>下面的程序段输出是（ ）。   D</p>  <figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-keyword">int</span> k=<span class="hljs-number">11</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;k=%d,k=%o,k=%x\n&quot;</span>,k,k,k);<br><br>A.k=<span class="hljs-number">11</span>,k=<span class="hljs-number">12</span>,k=<span class="hljs-number">11</span><br>B.k=<span class="hljs-number">11</span>,k=<span class="hljs-number">13</span>,k=<span class="hljs-number">13</span><br>C.k=<span class="hljs-number">11</span>,k=<span class="hljs-number">013</span>;k=<span class="hljs-number">0xb</span><br>D.k=<span class="hljs-number">11</span>,k=<span class="hljs-number">13</span>,k=b<br></code></pre></div></td></tr></table></figure></li><li><p>下面的程序段输出是（ ）。   B</p>  <figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-keyword">short</span> <span class="hljs-keyword">int</span> a;<br><span class="hljs-keyword">int</span> b = <span class="hljs-number">65536</span>;<br>a = b;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, a);<br><br>A<span class="hljs-number">.65536</span><br>B<span class="hljs-number">.0</span><br>C.<span class="hljs-number">-1</span><br>D<span class="hljs-number">.1</span><br></code></pre></div></td></tr></table></figure></li><li><p>阅读以下程序段，如果从键盘上输入<code>1234567&lt;回车&gt;</code>，则程序的运行结果是（ ）。    D</p>  <figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-keyword">int</span> i,j;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%3d%2d&quot;</span>,&amp;i,&amp;j);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i = %d, j = %d\n&quot;</span>,i,j);<br><br>A.i = <span class="hljs-number">123</span>, j = <span class="hljs-number">4567</span><br>B.i = <span class="hljs-number">1234</span>, j = <span class="hljs-number">567</span><br>C.i = <span class="hljs-number">1</span>, j = <span class="hljs-number">2</span><br>D.i = <span class="hljs-number">123</span>, j = <span class="hljs-number">45</span><br></code></pre></div></td></tr></table></figure></li><li><p>阅读以下程序段，如果从键盘上输入<code>abc&lt;回车&gt;</code>，则程序的运行结果是（ ）。A</p>  <figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-keyword">char</span> ch;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%3c&quot;</span>,&amp;ch);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>,ch);<br><br>A.a<br>B.b<br>C.c<br>D.语法出错<br></code></pre></div></td></tr></table></figure></li><li><p>已知字符<code>&#39;A&#39;</code>的ASCII码是<code>65</code>，分别对应八进制数<code>101</code>和十六进制数<code>41</code>，以下（ ）不能正确表示字符’A’。 D</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C">A<span class="hljs-number">.&#x27;</span>A<span class="hljs-number">&#x27;</span><br>B<span class="hljs-number">.&#x27;</span>\<span class="hljs-number">101&#x27;</span><br>C<span class="hljs-number">.&#x27;</span>\x41<span class="hljs-number">&#x27;</span><br>D<span class="hljs-number">.&#x27;</span>\<span class="hljs-number">0x41&#x27;</span><br></code></pre></div></td></tr></table></figure></li><li><p>设以下变量均为int类型，表达式的值不为<code>9</code>的是（）。  C</p>  <figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C">A.(x = y = <span class="hljs-number">8</span>, x+y, x+<span class="hljs-number">1</span>)<br>B.(x = y = <span class="hljs-number">8</span>, x+y, y+<span class="hljs-number">1</span>)<br>C.(x = <span class="hljs-number">8</span>, x+<span class="hljs-number">1</span>, y = <span class="hljs-number">8</span>, x+y)<br>D.(y = <span class="hljs-number">8</span>, y+<span class="hljs-number">1</span>, x = y, x+<span class="hljs-number">1</span>)<br></code></pre></div></td></tr></table></figure></li><li><p>运算符（ ）的优先级最高。   A</p>  <figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C">A.[ ]<br>B.+=<br>C.? :<br>D.++<br></code></pre></div></td></tr></table></figure></li><li><p>执行下面程序中的输出语句后，输出结果是（ ）。   B</p>  <figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-keyword">int</span> a;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,(a=<span class="hljs-number">3</span>*<span class="hljs-number">5</span>,a*<span class="hljs-number">4</span>,a+<span class="hljs-number">5</span>));<br><br>A<span class="hljs-number">.65</span><br>B<span class="hljs-number">.20</span><br>C<span class="hljs-number">.15</span><br>D<span class="hljs-number">.10</span><br></code></pre></div></td></tr></table></figure></li><li><p>以下关于函数叙述中，错误的是（ ）。 B   (不定参函数，隐式转换)</p><p>  A.函数未被调用时，系统将不为形参分配内存单元</p><p>  B.实参与形参的个数必须相等，且实参与形参的类型必须对应一致</p><p>  C.当形参是变量时，实参可以是变量、常量或表达式</p><p>  D.如函数调用时，实参与形参都为变量，则这两个变量不可能占用同一内存空间</p></li><li><p>(多)对于以下两个程序段，下列叙述正确的是（ ）。   ACF</p><p>  A.在程序段1和程序段2中，语句<code>y = x + 1;</code>的执行条件皆为满足<code>x&lt;1</code>。</p><p>  B.在程序段1和程序段2中，语句<code>y = x + 1;</code>的执行条件皆为满足<code>x&lt;2</code>。</p><p>  C.在程序段1中，语句<code>y = x + 2;</code>的执行条件是满足<code>x&gt;=2</code>。</p><p>  D.在程序段1中，语句<code>y = x + 2;</code>的执行条件是满足<code>x&gt;=1</code>且<code>x&lt;2</code>。</p><p>  E.在程序段2中，语句<code>y = x + 2;</code>的执行条件是满足<code>x&gt;=2</code>。</p><p>  F.在程序段2中，语句<code>y = x + 2;</code>的执行条件是满足<code>x&gt;=1</code>且<code>x&lt;2</code>。</p>  <figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C">/ * 程序段<span class="hljs-number">1</span> */<br><span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">2</span>)&#123;<br>    <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">1</span>)&#123;<br>        y = x + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    y = x + <span class="hljs-number">2</span>;<br>&#125;<br><br>/ * 程序段<span class="hljs-number">2</span> */<br><span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">2</span>)&#123;<br>    <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">1</span>)&#123;<br>        y = x + <span class="hljs-number">1</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        y = x + <span class="hljs-number">2</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>(多)设变量已正确定义，以下（）是合法的<code>switch</code>语句。    ACD</p>  <figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C">A.<br><span class="hljs-keyword">switch</span>(op)&#123;<br>    <span class="hljs-keyword">default</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Error\n&quot;</span>); <span class="hljs-keyword">break</span>;<br>&#125;<br><br>B.<br><span class="hljs-keyword">switch</span>(op)&#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, value1 * value2); <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, value1 + value2); <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, value1 - value2); <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, value1 * value2); <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Error\n&quot;</span>); <span class="hljs-keyword">break</span>;<br>&#125;<br><br>C.<br><span class="hljs-keyword">switch</span>(<span class="hljs-string">&#x27;/&#x27;</span>)&#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, value1 * value2); <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, value1 - value2); <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, value1 + value2); <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Error\n&quot;</span>); <span class="hljs-keyword">break</span>;<br>&#125;<br><br>D.<br><span class="hljs-keyword">switch</span>(op+<span class="hljs-number">1</span>)&#123;<br>    <span class="hljs-keyword">default</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Error\n&quot;</span>); <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, value1 * value2); <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, value1 + value2); <span class="hljs-keyword">break</span>;<br>&#125;<br><br>E.<br><span class="hljs-keyword">switch</span>(op)&#123;<br>    <span class="hljs-keyword">case</span> op == <span class="hljs-string">&#x27;+&#x27;</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, value1 + value2); <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Error\n&quot;</span>); <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>(多)设变量已正确定义，以下（）是合法的C语句。     AC</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C">A.<br><span class="hljs-keyword">if</span> ( n &lt;= <span class="hljs-number">10</span> );<br><br>B.<br><span class="hljs-keyword">switch</span> ( k ) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;one&quot;</span>); <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;two&quot;</span>); <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;one&quot;</span>); <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;zero&quot;</span>); <span class="hljs-keyword">break</span>;<br>&#125;<br><br>C.<br><span class="hljs-keyword">switch</span> ( k%<span class="hljs-number">2</span> ) &#123;<br>    <span class="hljs-keyword">default</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;zero&quot;</span>); <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;one&quot;</span>);<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>+<span class="hljs-number">1</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;two&quot;</span>);<br>&#125;<br><br>D.<br>n = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">switch</span> ( k ) &#123;<br>    <span class="hljs-keyword">case</span> n%<span class="hljs-number">3</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;one&quot;</span>);<br>    <span class="hljs-keyword">case</span> n%<span class="hljs-number">4</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;two&quot;</span>);<br>    <span class="hljs-keyword">default</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;zero&quot;</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>(多)选项（ ）与以下字符数组定义等价。 ABD</p>  <figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-keyword">static</span> <span class="hljs-keyword">char</span> s[<span class="hljs-number">6</span>] = &#123;<span class="hljs-string">&#x27;H&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;p&#x27;</span>, <span class="hljs-string">&#x27;p&#x27;</span>, <span class="hljs-string">&#x27;y&#x27;</span>, <span class="hljs-string">&#x27;\0&#x27;</span>&#125;;<br><br>A.<span class="hljs-keyword">static</span> <span class="hljs-keyword">char</span> s[<span class="hljs-number">6</span>] = &#123;<span class="hljs-string">&#x27;H&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;p&#x27;</span>, <span class="hljs-string">&#x27;p&#x27;</span>, <span class="hljs-string">&#x27;y&#x27;</span>&#125;;<br>B.<span class="hljs-keyword">static</span> <span class="hljs-keyword">char</span> s[<span class="hljs-number">6</span>] =<span class="hljs-string">&quot;Happy&quot;</span>;<br>C.<span class="hljs-keyword">static</span> <span class="hljs-keyword">char</span> s[<span class="hljs-number">6</span>] =&#123;<span class="hljs-string">&quot;Happy&quot;</span>&#125;;<br>D.<span class="hljs-keyword">static</span> <span class="hljs-keyword">char</span> s[<span class="hljs-number">6</span>] = &#123;<span class="hljs-string">&#x27;H&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;p&#x27;</span>, <span class="hljs-string">&#x27;p&#x27;</span>, <span class="hljs-string">&#x27;y&#x27;</span>, <span class="hljs-number">0</span>&#125;;<br></code></pre></div></td></tr></table></figure><p>  以下能正确定义数组并正确赋初值的语句是（）。    D C中改为<code>int c[][2]=&#123;&#123;1,2&#125;,&#123;3,4&#125;&#125;</code>则可</p>  <figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C">A.<span class="hljs-keyword">int</span> N=<span class="hljs-number">5</span>, b[N][N];<br>B.<span class="hljs-keyword">int</span> a[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>]=&#123;&#123;<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">3</span>&#125;&#125;;<br>C.<span class="hljs-keyword">int</span> c[<span class="hljs-number">2</span>][ ]=&#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;&#125;;<br>D.<span class="hljs-keyword">int</span> d[<span class="hljs-number">3</span>][<span class="hljs-number">2</span>]=&#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">34</span>&#125;&#125;;<br></code></pre></div></td></tr></table></figure></li><li><p>以下选项中，对基本类型相同的指针变量不能进行运算的运算符是 ( )。  A 指针相加无意义 相减为两指针相隔元素数</p><p>  A.+</p><p>  B.-</p><p>  C.=</p><p>  D.==</p></li><li><p>对于以下程序段，则叙述正确的是（ ）。 D</p>  <figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-keyword">char</span> s[ ]=<span class="hljs-string">&quot;china&quot;</span>; <br><span class="hljs-keyword">char</span> *p; <br>p = s;<br></code></pre></div></td></tr></table></figure><p>  A.<code>s</code>和<code>p</code>完全相同</p><p>  B.数组<code>s</code>中的内容和指针变量<code>p</code>中的内容相等</p><p>  C.数组<code>s</code>的长度和p所指向的字符串长度相等</p><p>  D.<code>*p</code>与<code>s[0]</code>相等</p></li><li><p>对于以下定义，错误的<code>scanf</code>函数调用语句是（）。 A</p>  <figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pupil</span>&#123;</span> <br>    <span class="hljs-keyword">char</span> name[<span class="hljs-number">20</span>];<br>    <span class="hljs-keyword">int</span> age;<br>    <span class="hljs-keyword">int</span> sex;<br>&#125;pup[<span class="hljs-number">5</span>];<br><br>A.<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, &amp;pup[<span class="hljs-number">0</span>].name);<br><br>B.<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;pup[<span class="hljs-number">1</span>].age);<br><br>C.<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;pup[<span class="hljs-number">2</span>].sex);<br><br>D.<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, pup[<span class="hljs-number">4</span>].name);<br></code></pre></div></td></tr></table></figure></li><li><p>以下程序的输出结果是（ ）。   C</p>  <figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stu</span>&#123;</span><br>    <span class="hljs-keyword">int</span> x; <br>    <span class="hljs-keyword">int</span> *y;<br>&#125; *p;<br><span class="hljs-keyword">int</span> dt[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stu</span> <span class="hljs-title">a</span>[4] =</span> &#123;<span class="hljs-number">50</span>, &amp;dt[<span class="hljs-number">0</span>], <span class="hljs-number">60</span>, &amp;dt[<span class="hljs-number">1</span>], <span class="hljs-number">70</span>, &amp;dt[<span class="hljs-number">2</span>], <span class="hljs-number">80</span>, &amp;dt[<span class="hljs-number">3</span>]&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">( )</span></span><br><span class="hljs-function"></span>&#123; <br>    p=a;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d,&quot;</span>, ++p-&gt;x);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d,&quot;</span>, (++p)-&gt;x);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, ++(*p-&gt;y));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>  A.10,20,20</p><p>  B.50,60,21</p><p>  C.51,60,21</p><p>  D.60,70,31</p></li><li><p>对于以下结构定义，<code>(*p)-&gt;str++</code>中的++加在（）。 D</p>  <figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span> <br>    <span class="hljs-keyword">int</span> len; <br>    <span class="hljs-keyword">char</span> *str<br>&#125; *p;<br></code></pre></div></td></tr></table></figure><p>  A.指针<code>str</code>上</p><p>  B.指针<code>p</code>上</p><p>  C.<code>str</code>指向的内容上</p><p>  D.语法错误</p></li><li><p>在“文件包含”预处理语句的使用过程中，当#include后面的文件名用双引号括起来时，寻找被包含文件的方式是( )。   B(用&lt;&gt;时选A)</p><p>  A.直接按系统设定的标准方式搜索目录</p><p>  B.先在源程序所在目录搜索，再按系统设定的标准方式搜索</p><p>  C.仅仅搜索源程序所在目录</p><p>  D.仅仅搜索当前目录</p></li><li><p>下面说法中正确的是（）。  A(题目可能存在问题)</p><p>  A.若全局变量仅在单个C文件中访问，则可以将这个变量修改为静态全局变量，以降低模块间的耦合度</p><p>  B.若全局变量仅由单个函数访问，则可以将这个变量改为该函数的静态局部变量，以降低模块间的耦合度</p><p>  C.设计和使用访问动态全局变量、静态全局变量、静态局部变量的函数时，需要考虑变量生命周期问题</p><p>  D.静态全局变量使用过多，可那会导致动态存储区（堆栈）溢出</p><p>  (B选项：仅仅由单个函数访问，不存在模块耦合度问题</p><p>  C选项：动态全局变量，静态全局变量，静态局部变量的生命周期都是整个程序运行期间，跟函数设计没有关系</p><p>  D选项：静态全局变量存储于全局（静态）数据区)</p></li><li><p>若fopen()函数打开文件失败，其返回值是（ ）。  C(成功返回file地址)<br>  A.1     B.-1    C.NULL  D.ERROR</p></li><li><p>若读文件还未读到文件末尾， feof()函数的返回值是（ ）。    B(结束为1)<br>  A.-1    B.0     C.1     D.非0</p></li><li><p>fputc(ch,fp) 把一个字符ch写到fp所指示的磁盘文件中，若写文件失败则函数的返回值为（ ）。    C(成功为ch)<br>  A.0     B.1     C.EOF   D.非0</p></li><li><p>缓冲文件系统的文件缓冲区位于（）。    C<br>  A.磁盘缓冲区中  </p><p>  B.磁盘文件中</p><p>  C.内存数据区中</p><p>  D.程序文件中</p></li><li><p>直接使文件指针重新定位到文件读写的首地址的函数是（） 。   C<br>  A.ftell()   B.fseek()</p><p>  C.rewind()  D.ferror()</p></li></ul><hr><h2 id="填空"><a href="#填空" class="headerlink" title="填空"></a>填空</h2><ul><li><p>若变量已正确定义，执行以下程序段，并回答下列问题。请注意，直接填数字，前后不要加空格等任何其他字符。</p>  <figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C">i = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (i &lt;= <span class="hljs-number">10</span>)<br>    i++;                 <span class="hljs-comment">/* 语句① */</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, i);   <span class="hljs-comment">/* 语句② */</span><br></code></pre></div></td></tr></table></figure><p>  语句①执行了?次</p><p>  语句②执行了?次</p><p>  循环体语句共执行了?次</p><p>  当循环结束时，变量<code>i</code>的值是?</p><p>  10 1 10 11</p></li><li><p>若变量已正确定义，写出以下程序段的运行结果。</p>  <figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-built_in">scanf</span> (<span class="hljs-string">&quot;%d&quot;</span>, &amp;k);  <br><span class="hljs-keyword">while</span>(k &gt;= <span class="hljs-number">0</span>)&#123;   <br>    <span class="hljs-built_in">scanf</span> (<span class="hljs-string">&quot;%d&quot;</span>, &amp;k); <br>     <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d#&quot;</span>, k);          <br>&#125;<br></code></pre></div></td></tr></table></figure><p>  输入<code>1 2 3 0 -1</code>，输出</p><p>  输入<code>1 0 2 3 -1</code>，输出</p><p>  输入<code>1 2 3 -1 9</code>，输出</p><p>  2#3#0#-1#</p><p>  0#2#3#-1#</p><p>  2#3#-1#</p></li><li><p>若变量已正确定义，写出以下程序段的运行结果。</p>  <figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-built_in">scanf</span> (<span class="hljs-string">&quot;%d&quot;</span>, &amp;m);<br>limit = <span class="hljs-built_in">sqrt</span>(m) + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(i = <span class="hljs-number">2</span>; i &lt;= limit; i++)&#123;<br>    <span class="hljs-keyword">if</span>(m % i == <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;No&quot;</span>);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Yes&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>  输入<code>9</code>，输出</p><p>  输入<code>4</code>，输出</p><p>  YesNoYes</p><p>  NoYes</p></li><li><p>写出以下程序的运行结果。请注意，直接填数字或者字符，前、后和中间不要加空格。</p>  <figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> c1 = <span class="hljs-number">0</span>, c2 = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">char</span> ch;                      <br>    <span class="hljs-keyword">while</span>((ch = getchar()) != <span class="hljs-string">&#x27;#&#x27;</span>)&#123;<br>        <span class="hljs-keyword">switch</span>(ch)&#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;a&#x27;</span>:<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;h&#x27;</span>: c1++;<br>            <span class="hljs-keyword">default</span>: c2++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;c1=%d,c2=%d\n&quot;</span>, c1, c2);   <span class="hljs-comment">/* 中间、前、后都没有空格 */</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>  输入<code>china#</code>，输出（）<br>  c1=2,c2=5</p></li><li><p>写出以下程序段的运行结果。请注意，直接填单词、字符或者两者的组合，前后不要加空格等任何其他字符。</p>  <figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-keyword">double</span> grade; <br><span class="hljs-built_in">scanf</span> (<span class="hljs-string">&quot;%lf&quot;</span>, &amp;grade); <br><span class="hljs-keyword">if</span>(grade &lt; <span class="hljs-number">60</span>); &#123;    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Fail&quot;</span>); <br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;?&quot;</span>); <br></code></pre></div></td></tr></table></figure><p>  输入<code>50</code>，输出</p><p>  输入<code>60</code>，输出</p><p>  输入<code>90</code>，输出</p><p>  Fail?</p><p>  Fail?</p><p>  Fail?</p></li><li><p>假设整型数据用两个字节表示，则用二进制表示-127的原码为？反码为？补码为？</p><p>  1000000001111111 1111111110000000 1111111110000001</p></li><li><p>以下程序的运行结果是</p>  <figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ps</span>&#123;</span><br>    <span class="hljs-keyword">double</span> i;<br>    <span class="hljs-keyword">char</span> arr[<span class="hljs-number">24</span>];<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ps</span> <span class="hljs-title">s</span>[3], *<span class="hljs-title">p1</span>, *<span class="hljs-title">p2</span>;</span><br>    p1=s;  <br>    p2=s+<span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d,%d\n&quot;</span>, p2-p1, <span class="hljs-keyword">sizeof</span>(struct ps)); <span class="hljs-comment">/* 输出数据之间没有空格分隔 */</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>  2,32</p></li><li><p>以下程序的运行结果是</p>  <figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">st</span>&#123;</span><br><span class="hljs-keyword">char</span> c; <br><span class="hljs-keyword">char</span> s[<span class="hljs-number">80</span>];<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span>  <span class="hljs-title">st</span> <span class="hljs-title">a</span>[4] =</span> &#123;&#123;<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&quot;123&quot;</span>&#125;, &#123;<span class="hljs-string">&#x27;2&#x27;</span>,<span class="hljs-string">&quot;321&quot;</span>&#125;, &#123;<span class="hljs-string">&#x27;3&#x27;</span>,<span class="hljs-string">&quot;123&quot;</span>&#125;, &#123;<span class="hljs-string">&#x27;4&#x27;</span>,<span class="hljs-string">&quot;321&quot;</span>&#125;&#125;;<br><span class="hljs-function"><span class="hljs-keyword">char</span> * <span class="hljs-title">f</span><span class="hljs-params">(struct st *t)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">( )</span></span><br><span class="hljs-function"></span>&#123;   <span class="hljs-keyword">int</span> k;<br>    <span class="hljs-keyword">for</span>(k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">4</span>; k++)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, f(a+k));<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">char</span> * <span class="hljs-title">f</span><span class="hljs-params">(struct st *t)</span></span><br><span class="hljs-function"></span>&#123;   <br>    <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(t-&gt;s[k] != <span class="hljs-string">&#x27;\0&#x27;</span>)&#123;<br>        <span class="hljs-keyword">if</span>( t-&gt;s[k] == t-&gt;c)&#123;<br>        <span class="hljs-keyword">return</span> t-&gt;s+k;<br>        &#125;<br>        k++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> t-&gt;s;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>  123213321</p></li><li><p>运行以下程序段，第1行输出?，第2行输出?</p>  <figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-keyword">int</span> a; <span class="hljs-keyword">int</span> *b;<br>&#125; s[<span class="hljs-number">4</span>], *p;<br><span class="hljs-keyword">int</span> i, n = <span class="hljs-number">1</span>;    <br><span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)&#123;<br>    s[i].a = n;<br>    s[i].b = &amp;s[i].a;<br>    n = n + <span class="hljs-number">2</span>;<br>&#125;<br>p = &amp;s[<span class="hljs-number">0</span>];<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, ++*p-&gt;b);<br>p++;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d,%d\n&quot;</span>, (++p)-&gt;a, (p++)-&gt;a);  <span class="hljs-comment">/* 输出数据之间没有空格分隔 */</span><br></code></pre></div></td></tr></table></figure><p>  2</p><p>  7,3</p><p>  (<code>printf</code>从右向左计算)</p></li><li><p>```C<br>  printf(“%.3lf\n”, 2.0/3);</p>  <figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">    输出：<br>    <span class="hljs-number">0.667</span>   (会四舍五入)<br><br>- 阅读以下程序并回答问题。<br>    ```C<br>    <span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span><br><span class="hljs-function">    </span>&#123;   <br>        <span class="hljs-keyword">int</span> s = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(n--)&#123;<br>            s += n;<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d,%d\n&quot;</span>, n, s);  <span class="hljs-comment">/* 中间没有空格 */</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function">    </span>&#123;    <br>        <span class="hljs-built_in">f2</span>(<span class="hljs-number">4</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br></code></pre></div></td></tr></table></figure><p>  输出：<br>  -1,6(not 4,6)</p></li><li><p>阅读以下程序并回答问题。</p>  <figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f2</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;   <br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>, s;<br>    s = s + k;<br>    k++;<br>    <span class="hljs-keyword">return</span> s;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;   <br>    <span class="hljs-keyword">int</span> i;<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">3</span>; i++)&#123;<br>        f2();<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, f2());<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>  输出：<br>  10(not 4)   //静态变量不会重新赋初值</p></li><li><p>根据数据存储的编码形式，C语言中处理的数据文件通常为?文件和?文件两种。</p></li><li><p>C语言中，在成功打开一个文件后，可以使用?来获取文件缓冲区的FILE结构信息。</p></li><li><p>fgets(s,n,fp);语句用来从fp所指示的文本文件中读取字符串s，该语句最多读取?个字符。</p><p>  n-1</p></li></ul><h1 id="零零散散"><a href="#零零散散" class="headerlink" title="零零散散"></a>零零散散</h1><ul><li><p>逗号表达式 从左到右计算，返回值为最后一个表达式的值</p></li><li><p>取反后需转为原码 如对10取反为-11</p></li><li><p>strcpy() 后面字符串复制到前面字符串 覆盖</p></li><li><p>文件打开参数 <a href="https://www.cnblogs.com/kangjianwei101/p/5220021.html">https://www.cnblogs.com/kangjianwei101/p/5220021.html</a></p></li><li><p>实数存储方式 符号 阶码(移码表示的乘幂指数) 尾数   没有基数(乘幂的底数)</p></li><li><p>二维指针 <code>*(*(p+1)+1) </code> 表示<code>p[1][1]</code></p></li><li><p>指针数组和数组指针 <code>int *p1[5]</code> 每个元素都是指针 <code>int (*p2)[5]</code> 一个指向数组的指针</p></li><li><p>sizeof()表达式的值在编译时确定。编译器不计算其中表达式的值，仅将其替换为对应类型。</p></li><li><p>scanf遇到空白字符截止，为输入一行可使用 scanf(“[^\n]”,str) 或gets()。</p><p>  注意：scanf(“%s”, s)输入 “How are you?” 遇到空格截断，只得到How。</p></li><li><p>位运算是根据内存中的二进制位进行运算的</p></li><li><p>true false等不是保留关键字</p></li><li><p>左移运算符&lt;&lt;用来把操作数的各个二进制位全部左移若干位，高位丢弃，低位补0。</p></li><li><p>右移运算符&gt;&gt;用来把操作数的各个二进制位全部右移若干位，低位丢弃，高位补 0 或 1。如果数据的最高位是 0，那么就补 0；如果最高位是 1，那么就补 1。</p></li></ul><h1 id="补个优先级表格"><a href="#补个优先级表格" class="headerlink" title="补个优先级表格"></a>补个优先级表格</h1><p><img src="operate.jpeg" alt="优先级表格"></p>]]></content>
    
    
    
    <tags>
      
      <tag>c</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
